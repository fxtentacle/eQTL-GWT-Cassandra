/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.cassandra.service;

/*
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 */

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.thrift.TBase;
import org.apache.thrift.TBaseHelper;
import org.apache.thrift.TException;
import org.apache.thrift.TFieldRequirementType;
import org.apache.thrift.meta_data.FieldMetaData;
import org.apache.thrift.meta_data.FieldValueMetaData;
import org.apache.thrift.meta_data.ListMetaData;
import org.apache.thrift.meta_data.StructMetaData;
import org.apache.thrift.protocol.TField;
import org.apache.thrift.protocol.TList;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.protocol.TProtocolUtil;
import org.apache.thrift.protocol.TStruct;
import org.apache.thrift.protocol.TType;

/**
 * A KeySlice is key followed by the data it maps to. A collection of KeySlice
 * is returned by the get_range_slice operation.
 * 
 * @param key
 *            . a row key
 * @param columns
 *            . List of data represented by the key. Typically, the list is
 *            pared down to only the columns specified by a SlicePredicate.
 */
public class KeySlice implements TBase, java.io.Serializable, Cloneable, Comparable<KeySlice> {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private static final TStruct STRUCT_DESC = new TStruct("KeySlice");
	private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short) 1);
	private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short) 2);

	public String key;
	public List<ColumnOrSuperColumn> columns;
	public static final int KEY = 1;
	public static final int COLUMNS = 2;

	// isset id assignments

	public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
		/**
	 * 
	 */
		private static final long serialVersionUID = 1L;

		{
			put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
			put(COLUMNS, new FieldMetaData("columns", TFieldRequirementType.REQUIRED, new ListMetaData(TType.LIST, new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
		}
	});

	static {
		FieldMetaData.addStructMetaDataMap(KeySlice.class, metaDataMap);
	}

	public KeySlice() {
	}

	public KeySlice(String key, List<ColumnOrSuperColumn> columns) {
		this();
		this.key = key;
		this.columns = columns;
	}

	/**
	 * Performs a deep copy on <i>other</i>.
	 */
	public KeySlice(KeySlice other) {
		if (other.isSetKey()) {
			this.key = other.key;
		}
		if (other.isSetColumns()) {
			List<ColumnOrSuperColumn> __this__columns = new ArrayList<ColumnOrSuperColumn>();
			for (ColumnOrSuperColumn other_element : other.columns) {
				__this__columns.add(new ColumnOrSuperColumn(other_element));
			}
			this.columns = __this__columns;
		}
	}

	public KeySlice deepCopy() {
		return new KeySlice(this);
	}

	@Override
	@Deprecated
	public KeySlice clone() {
		return new KeySlice(this);
	}

	public String getKey() {
		return this.key;
	}

	public KeySlice setKey(String key) {
		this.key = key;
		return this;
	}

	public void unsetKey() {
		this.key = null;
	}

	// Returns true if field key is set (has been asigned a value) and false
	// otherwise
	public boolean isSetKey() {
		return this.key != null;
	}

	public void setKeyIsSet(boolean value) {
		if (!value) {
			this.key = null;
		}
	}

	public int getColumnsSize() {
		return (this.columns == null) ? 0 : this.columns.size();
	}

	public java.util.Iterator<ColumnOrSuperColumn> getColumnsIterator() {
		return (this.columns == null) ? null : this.columns.iterator();
	}

	public void addToColumns(ColumnOrSuperColumn elem) {
		if (this.columns == null) {
			this.columns = new ArrayList<ColumnOrSuperColumn>();
		}
		this.columns.add(elem);
	}

	public List<ColumnOrSuperColumn> getColumns() {
		return this.columns;
	}

	public KeySlice setColumns(List<ColumnOrSuperColumn> columns) {
		this.columns = columns;
		return this;
	}

	public void unsetColumns() {
		this.columns = null;
	}

	// Returns true if field columns is set (has been asigned a value) and false
	// otherwise
	public boolean isSetColumns() {
		return this.columns != null;
	}

	public void setColumnsIsSet(boolean value) {
		if (!value) {
			this.columns = null;
		}
	}

	@SuppressWarnings("unchecked")
	public void setFieldValue(int fieldID, Object value) {
		switch (fieldID) {
		case KEY:
			if (value == null) {
				unsetKey();
			} else {
				setKey((String) value);
			}
			break;

		case COLUMNS:
			if (value == null) {
				unsetColumns();
			} else {
				setColumns((List<ColumnOrSuperColumn>) value);
			}
			break;

		default:
			throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
		}
	}

	public Object getFieldValue(int fieldID) {
		switch (fieldID) {
		case KEY:
			return getKey();

		case COLUMNS:
			return getColumns();

		default:
			throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
		}
	}

	// Returns true if field corresponding to fieldID is set (has been asigned a
	// value) and false otherwise
	public boolean isSet(int fieldID) {
		switch (fieldID) {
		case KEY:
			return isSetKey();
		case COLUMNS:
			return isSetColumns();
		default:
			throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
		}
	}

	@Override
	public boolean equals(Object that) {
		if (that == null)
			return false;
		if (that instanceof KeySlice)
			return this.equals((KeySlice) that);
		return false;
	}

	public boolean equals(KeySlice that) {
		if (that == null)
			return false;

		boolean this_present_key = true && this.isSetKey();
		boolean that_present_key = true && that.isSetKey();
		if (this_present_key || that_present_key) {
			if (!(this_present_key && that_present_key))
				return false;
			if (!this.key.equals(that.key))
				return false;
		}

		boolean this_present_columns = true && this.isSetColumns();
		boolean that_present_columns = true && that.isSetColumns();
		if (this_present_columns || that_present_columns) {
			if (!(this_present_columns && that_present_columns))
				return false;
			if (!this.columns.equals(that.columns))
				return false;
		}

		return true;
	}

	@Override
	public int hashCode() {
		return 0;
	}

	public int compareTo(KeySlice other) {
		if (!getClass().equals(other.getClass())) {
			return getClass().getName().compareTo(other.getClass().getName());
		}

		int lastComparison = 0;
		KeySlice typedOther = other;

		lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
		if (lastComparison != 0) {
			return lastComparison;
		}
		lastComparison = TBaseHelper.compareTo(key, typedOther.key);
		if (lastComparison != 0) {
			return lastComparison;
		}
		lastComparison = Boolean.valueOf(isSetColumns()).compareTo(isSetColumns());
		if (lastComparison != 0) {
			return lastComparison;
		}
		lastComparison = TBaseHelper.compareTo(columns, typedOther.columns);
		if (lastComparison != 0) {
			return lastComparison;
		}
		return 0;
	}

	public void read(TProtocol iprot) throws TException {
		TField field;
		iprot.readStructBegin();
		while (true) {
			field = iprot.readFieldBegin();
			if (field.type == TType.STOP) {
				break;
			}
			switch (field.id) {
			case KEY:
				if (field.type == TType.STRING) {
					this.key = iprot.readString();
				} else {
					TProtocolUtil.skip(iprot, field.type);
				}
				break;
			case COLUMNS:
				if (field.type == TType.LIST) {
					{
						TList _list8 = iprot.readListBegin();
						this.columns = new ArrayList<ColumnOrSuperColumn>(_list8.size);
						for (int _i9 = 0; _i9 < _list8.size; ++_i9) {
							ColumnOrSuperColumn _elem10;
							_elem10 = new ColumnOrSuperColumn();
							_elem10.read(iprot);
							this.columns.add(_elem10);
						}
						iprot.readListEnd();
					}
				} else {
					TProtocolUtil.skip(iprot, field.type);
				}
				break;
			default:
				TProtocolUtil.skip(iprot, field.type);
				break;
			}
			iprot.readFieldEnd();
		}
		iprot.readStructEnd();

		// check for required fields of primitive type, which can't be checked
		// in the validate method
		validate();
	}

	public void write(TProtocol oprot) throws TException {
		validate();

		oprot.writeStructBegin(STRUCT_DESC);
		if (this.key != null) {
			oprot.writeFieldBegin(KEY_FIELD_DESC);
			oprot.writeString(this.key);
			oprot.writeFieldEnd();
		}
		if (this.columns != null) {
			oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
			{
				oprot.writeListBegin(new TList(TType.STRUCT, this.columns.size()));
				for (ColumnOrSuperColumn _iter11 : this.columns) {
					_iter11.write(oprot);
				}
				oprot.writeListEnd();
			}
			oprot.writeFieldEnd();
		}
		oprot.writeFieldStop();
		oprot.writeStructEnd();
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder("KeySlice(");
		boolean first = true;

		sb.append("key:");
		if (this.key == null) {
			sb.append("null");
		} else {
			sb.append(this.key);
		}
		first = false;
		if (!first)
			sb.append(", ");
		sb.append("columns:");
		if (this.columns == null) {
			sb.append("null");
		} else {
			sb.append(this.columns);
		}
		first = false;
		sb.append(")");
		return sb.toString();
	}

	public void validate() throws TException {
		// check for required fields
		if (key == null) {
			throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
		}
		if (columns == null) {
			throw new TProtocolException("Required field 'columns' was not present! Struct: " + toString());
		}
		// check that fields of type enum have valid values
	}

}
