/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.cassandra.service;

/*
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 */

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.thrift.TApplicationException;
import org.apache.thrift.TBase;
import org.apache.thrift.TBaseHelper;
import org.apache.thrift.TException;
import org.apache.thrift.TFieldRequirementType;
import org.apache.thrift.TProcessor;
import org.apache.thrift.meta_data.FieldMetaData;
import org.apache.thrift.meta_data.FieldValueMetaData;
import org.apache.thrift.meta_data.ListMetaData;
import org.apache.thrift.meta_data.MapMetaData;
import org.apache.thrift.meta_data.StructMetaData;
import org.apache.thrift.protocol.TField;
import org.apache.thrift.protocol.TList;
import org.apache.thrift.protocol.TMap;
import org.apache.thrift.protocol.TMessage;
import org.apache.thrift.protocol.TMessageType;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.protocol.TProtocolUtil;
import org.apache.thrift.protocol.TStruct;
import org.apache.thrift.protocol.TType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Cassandra {

	public interface Iface {

		/**
		 * Get the Column or SuperColumn at the given column_path. If no value
		 * is present, NotFoundException is thrown. (This is the only method
		 * that can throw an exception under non-failure conditions.)
		 * 
		 * @param keyspace
		 * @param key
		 * @param column_path
		 * @param consistency_level
		 */
		public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException,
				TimedOutException, TException;

		/**
		 * Get the group of columns contained by column_parent (either a
		 * ColumnFamily name or a ColumnFamily/SuperColumn name pair) specified
		 * by the given SlicePredicate. If no matching values are found, an
		 * empty list is returned.
		 * 
		 * @param keyspace
		 * @param key
		 * @param column_parent
		 * @param predicate
		 * @param consistency_level
		 */
		public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException,
				UnavailableException, TimedOutException, TException;

		/**
		 * Perform a get for column_path in parallel on the given list<string>
		 * keys. The return value maps keys to the ColumnOrSuperColumn found. If
		 * no value corresponding to a key is present, the key will still be in
		 * the map, but both the column and super_column references of the
		 * ColumnOrSuperColumn object it maps to will be null.
		 * 
		 * @param keyspace
		 * @param keys
		 * @param column_path
		 * @param consistency_level
		 */
		public Map<String, ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException;

		/**
		 * Performs a get_slice for column_parent and predicate for the given
		 * keys in parallel.
		 * 
		 * @param keyspace
		 * @param keys
		 * @param column_parent
		 * @param predicate
		 * @param consistency_level
		 */
		public Map<String, List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
				throws InvalidRequestException, UnavailableException, TimedOutException, TException;

		/**
		 * returns the number of columns for a particular <code>key</code> and
		 * <code>ColumnFamily</code> or <code>SuperColumn</code>.
		 * 
		 * @param keyspace
		 * @param key
		 * @param column_parent
		 * @param consistency_level
		 */
		public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;

		/**
		 * @deprecated; use get_range_slice instead
		 * 
		 * @param keyspace
		 * @param column_family
		 * @param start
		 * @param finish
		 * @param count
		 * @param consistency_level
		 */
		public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException;

		/**
		 * returns a subset of columns for a range of keys.
		 * 
		 * @param keyspace
		 * @param column_parent
		 * @param predicate
		 * @param start_key
		 * @param finish_key
		 * @param row_count
		 * @param consistency_level
		 */
		public List<KeySlice> get_range_slice(String keyspace, ColumnParent column_parent, SlicePredicate predicate, String start_key, String finish_key, int row_count, int consistency_level)
				throws InvalidRequestException, UnavailableException, TimedOutException, TException;

		/**
		 * Insert a Column consisting of (column_path.column, value, timestamp)
		 * at the given column_path.column_family and optional
		 * column_path.super_column. Note that column_path.column is here
		 * required, since a SuperColumn cannot directly contain binary values
		 * -- it can only contain sub-Columns.
		 * 
		 * @param keyspace
		 * @param key
		 * @param column_path
		 * @param value
		 * @param timestamp
		 * @param consistency_level
		 */
		public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException;

		/**
		 * Insert Columns or SuperColumns across different Column Families for
		 * the same row key. batch_mutation is a map<string,
		 * list<ColumnOrSuperColumn>> -- a map which pairs column family names
		 * with the relevant ColumnOrSuperColumn objects to insert.
		 * 
		 * @param keyspace
		 * @param key
		 * @param cfmap
		 * @param consistency_level
		 */
		public void batch_insert(String keyspace, String key, Map<String, List<ColumnOrSuperColumn>> cfmap, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException;

		/**
		 * Remove data from the row specified by key at the granularity
		 * specified by column_path, and the given timestamp. Note that all the
		 * values in column_path besides column_path.column_family are truly
		 * optional: you can remove the entire row by just specifying the
		 * ColumnFamily, or you can remove a SuperColumn or a single Column by
		 * specifying those levels too.
		 * 
		 * @param keyspace
		 * @param key
		 * @param column_path
		 * @param timestamp
		 * @param consistency_level
		 */
		public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException,
				TException;

		/**
		 * get property whose value is of type string.
		 * 
		 * @param property
		 */
		public String get_string_property(String property) throws TException;

		/**
		 * get property whose value is list of strings.
		 * 
		 * @param property
		 */
		public List<String> get_string_list_property(String property) throws TException;

		/**
		 * describe specified keyspace
		 * 
		 * @param keyspace
		 */
		public Map<String, Map<String, String>> describe_keyspace(String keyspace) throws NotFoundException, TException;

	}

	public static class Client implements Iface {
		public Client(TProtocol prot) {
			this(prot, prot);
		}

		public Client(TProtocol iprot, TProtocol oprot) {
			iprot_ = iprot;
			oprot_ = oprot;
		}

		protected TProtocol iprot_;
		protected TProtocol oprot_;

		protected int seqid_;

		public TProtocol getInputProtocol() {
			return this.iprot_;
		}

		public TProtocol getOutputProtocol() {
			return this.oprot_;
		}

		public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException,
				TimedOutException, TException {
			send_get(keyspace, key, column_path, consistency_level);
			return recv_get();
		}

		public void send_get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
			get_args args = new get_args();
			args.keyspace = keyspace;
			args.key = key;
			args.column_path = column_path;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public ColumnOrSuperColumn recv_get() throws InvalidRequestException, NotFoundException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			get_result result = new get_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.nfe != null) {
				throw result.nfe;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
		}

		public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException,
				UnavailableException, TimedOutException, TException {
			send_get_slice(keyspace, key, column_parent, predicate, consistency_level);
			return recv_get_slice();
		}

		public void send_get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("get_slice", TMessageType.CALL, seqid_));
			get_slice_args args = new get_slice_args();
			args.keyspace = keyspace;
			args.key = key;
			args.column_parent = column_parent;
			args.predicate = predicate;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public List<ColumnOrSuperColumn> recv_get_slice() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			get_slice_result result = new get_slice_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
		}

		public Map<String, ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException {
			send_multiget(keyspace, keys, column_path, consistency_level);
			return recv_multiget();
		}

		public void send_multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("multiget", TMessageType.CALL, seqid_));
			multiget_args args = new multiget_args();
			args.keyspace = keyspace;
			args.keys = keys;
			args.column_path = column_path;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public Map<String, ColumnOrSuperColumn> recv_multiget() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			multiget_result result = new multiget_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget failed: unknown result");
		}

		public Map<String, List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
				throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			send_multiget_slice(keyspace, keys, column_parent, predicate, consistency_level);
			return recv_multiget_slice();
		}

		public void send_multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("multiget_slice", TMessageType.CALL, seqid_));
			multiget_slice_args args = new multiget_slice_args();
			args.keyspace = keyspace;
			args.keys = keys;
			args.column_parent = column_parent;
			args.predicate = predicate;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public Map<String, List<ColumnOrSuperColumn>> recv_multiget_slice() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			multiget_slice_result result = new multiget_slice_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget_slice failed: unknown result");
		}

		public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			send_get_count(keyspace, key, column_parent, consistency_level);
			return recv_get_count();
		}

		public void send_get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("get_count", TMessageType.CALL, seqid_));
			get_count_args args = new get_count_args();
			args.keyspace = keyspace;
			args.key = key;
			args.column_parent = column_parent;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public int recv_get_count() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			get_count_result result = new get_count_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_count failed: unknown result");
		}

		public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException {
			send_get_key_range(keyspace, column_family, start, finish, count, consistency_level);
			return recv_get_key_range();
		}

		public void send_get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("get_key_range", TMessageType.CALL, seqid_));
			get_key_range_args args = new get_key_range_args();
			args.keyspace = keyspace;
			args.column_family = column_family;
			args.start = start;
			args.finish = finish;
			args.count = count;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public List<String> recv_get_key_range() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			get_key_range_result result = new get_key_range_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_key_range failed: unknown result");
		}

		public List<KeySlice> get_range_slice(String keyspace, ColumnParent column_parent, SlicePredicate predicate, String start_key, String finish_key, int row_count, int consistency_level)
				throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			send_get_range_slice(keyspace, column_parent, predicate, start_key, finish_key, row_count, consistency_level);
			return recv_get_range_slice();
		}

		public void send_get_range_slice(String keyspace, ColumnParent column_parent, SlicePredicate predicate, String start_key, String finish_key, int row_count, int consistency_level)
				throws TException {
			oprot_.writeMessageBegin(new TMessage("get_range_slice", TMessageType.CALL, seqid_));
			get_range_slice_args args = new get_range_slice_args();
			args.keyspace = keyspace;
			args.column_parent = column_parent;
			args.predicate = predicate;
			args.start_key = start_key;
			args.finish_key = finish_key;
			args.row_count = row_count;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public List<KeySlice> recv_get_range_slice() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			get_range_slice_result result = new get_range_slice_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_range_slice failed: unknown result");
		}

		public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException {
			send_insert(keyspace, key, column_path, value, timestamp, consistency_level);
			recv_insert();
		}

		public void send_insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("insert", TMessageType.CALL, seqid_));
			insert_args args = new insert_args();
			args.keyspace = keyspace;
			args.key = key;
			args.column_path = column_path;
			args.value = value;
			args.timestamp = timestamp;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public void recv_insert() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			insert_result result = new insert_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			return;
		}

		public void batch_insert(String keyspace, String key, Map<String, List<ColumnOrSuperColumn>> cfmap, int consistency_level) throws InvalidRequestException, UnavailableException,
				TimedOutException, TException {
			send_batch_insert(keyspace, key, cfmap, consistency_level);
			recv_batch_insert();
		}

		public void send_batch_insert(String keyspace, String key, Map<String, List<ColumnOrSuperColumn>> cfmap, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("batch_insert", TMessageType.CALL, seqid_));
			batch_insert_args args = new batch_insert_args();
			args.keyspace = keyspace;
			args.key = key;
			args.cfmap = cfmap;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public void recv_batch_insert() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			batch_insert_result result = new batch_insert_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			return;
		}

		public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException,
				TException {
			send_remove(keyspace, key, column_path, timestamp, consistency_level);
			recv_remove();
		}

		public void send_remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws TException {
			oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
			remove_args args = new remove_args();
			args.keyspace = keyspace;
			args.key = key;
			args.column_path = column_path;
			args.timestamp = timestamp;
			args.consistency_level = consistency_level;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public void recv_remove() throws InvalidRequestException, UnavailableException, TimedOutException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			remove_result result = new remove_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.ire != null) {
				throw result.ire;
			}
			if (result.ue != null) {
				throw result.ue;
			}
			if (result.te != null) {
				throw result.te;
			}
			return;
		}

		public String get_string_property(String property) throws TException {
			send_get_string_property(property);
			return recv_get_string_property();
		}

		public void send_get_string_property(String property) throws TException {
			oprot_.writeMessageBegin(new TMessage("get_string_property", TMessageType.CALL, seqid_));
			get_string_property_args args = new get_string_property_args();
			args.property = property;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public String recv_get_string_property() throws TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			get_string_property_result result = new get_string_property_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_string_property failed: unknown result");
		}

		public List<String> get_string_list_property(String property) throws TException {
			send_get_string_list_property(property);
			return recv_get_string_list_property();
		}

		public void send_get_string_list_property(String property) throws TException {
			oprot_.writeMessageBegin(new TMessage("get_string_list_property", TMessageType.CALL, seqid_));
			get_string_list_property_args args = new get_string_list_property_args();
			args.property = property;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public List<String> recv_get_string_list_property() throws TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			get_string_list_property_result result = new get_string_list_property_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_string_list_property failed: unknown result");
		}

		public Map<String, Map<String, String>> describe_keyspace(String keyspace) throws NotFoundException, TException {
			send_describe_keyspace(keyspace);
			return recv_describe_keyspace();
		}

		public void send_describe_keyspace(String keyspace) throws TException {
			oprot_.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.CALL, seqid_));
			describe_keyspace_args args = new describe_keyspace_args();
			args.keyspace = keyspace;
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public Map<String, Map<String, String>> recv_describe_keyspace() throws NotFoundException, TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			describe_keyspace_result result = new describe_keyspace_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			if (result.nfe != null) {
				throw result.nfe;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_keyspace failed: unknown result");
		}

	}

	public static class Processor implements TProcessor {
		private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());

		public Processor(Iface iface) {
			iface_ = iface;
			processMap_.put("get", new get());
			processMap_.put("get_slice", new get_slice());
			processMap_.put("multiget", new multiget());
			processMap_.put("multiget_slice", new multiget_slice());
			processMap_.put("get_count", new get_count());
			processMap_.put("get_key_range", new get_key_range());
			processMap_.put("get_range_slice", new get_range_slice());
			processMap_.put("insert", new insert());
			processMap_.put("batch_insert", new batch_insert());
			processMap_.put("remove", new remove());
			processMap_.put("get_string_property", new get_string_property());
			processMap_.put("get_string_list_property", new get_string_list_property());
			processMap_.put("describe_keyspace", new describe_keyspace());
		}

		protected static interface ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
		}

		private Iface iface_;
		protected final HashMap<String, ProcessFunction> processMap_ = new HashMap<String, ProcessFunction>();

		public boolean process(TProtocol iprot, TProtocol oprot) throws TException {
			TMessage msg = iprot.readMessageBegin();
			ProcessFunction fn = processMap_.get(msg.name);
			if (fn == null) {
				TProtocolUtil.skip(iprot, TType.STRUCT);
				iprot.readMessageEnd();
				TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '" + msg.name + "'");
				oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
				x.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
				return true;
			}
			fn.process(msg.seqid, iprot, oprot);
			return true;
		}

		private class get implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				get_args args = new get_args();
				args.read(iprot);
				iprot.readMessageEnd();
				get_result result = new get_result();
				try {
					result.success = iface_.get(args.keyspace, args.key, args.column_path, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (NotFoundException nfe) {
					result.nfe = nfe;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing get", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
					oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class get_slice implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				get_slice_args args = new get_slice_args();
				args.read(iprot);
				iprot.readMessageEnd();
				get_slice_result result = new get_slice_result();
				try {
					result.success = iface_.get_slice(args.keyspace, args.key, args.column_parent, args.predicate, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing get_slice", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice");
					oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class multiget implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				multiget_args args = new multiget_args();
				args.read(iprot);
				iprot.readMessageEnd();
				multiget_result result = new multiget_result();
				try {
					result.success = iface_.multiget(args.keyspace, args.keys, args.column_path, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing multiget", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget");
					oprot.writeMessageBegin(new TMessage("multiget", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("multiget", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class multiget_slice implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				multiget_slice_args args = new multiget_slice_args();
				args.read(iprot);
				iprot.readMessageEnd();
				multiget_slice_result result = new multiget_slice_result();
				try {
					result.success = iface_.multiget_slice(args.keyspace, args.keys, args.column_parent, args.predicate, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing multiget_slice", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget_slice");
					oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class get_count implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				get_count_args args = new get_count_args();
				args.read(iprot);
				iprot.readMessageEnd();
				get_count_result result = new get_count_result();
				try {
					result.success = iface_.get_count(args.keyspace, args.key, args.column_parent, args.consistency_level);
					result.setSuccessIsSet(true);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing get_count", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_count");
					oprot.writeMessageBegin(new TMessage("get_count", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("get_count", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class get_key_range implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				get_key_range_args args = new get_key_range_args();
				args.read(iprot);
				iprot.readMessageEnd();
				get_key_range_result result = new get_key_range_result();
				try {
					result.success = iface_.get_key_range(args.keyspace, args.column_family, args.start, args.finish, args.count, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing get_key_range", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_key_range");
					oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class get_range_slice implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				get_range_slice_args args = new get_range_slice_args();
				args.read(iprot);
				iprot.readMessageEnd();
				get_range_slice_result result = new get_range_slice_result();
				try {
					result.success = iface_.get_range_slice(args.keyspace, args.column_parent, args.predicate, args.start_key, args.finish_key, args.row_count, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing get_range_slice", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_range_slice");
					oprot.writeMessageBegin(new TMessage("get_range_slice", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("get_range_slice", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class insert implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				insert_args args = new insert_args();
				args.read(iprot);
				iprot.readMessageEnd();
				insert_result result = new insert_result();
				try {
					iface_.insert(args.keyspace, args.key, args.column_path, args.value, args.timestamp, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing insert", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing insert");
					oprot.writeMessageBegin(new TMessage("insert", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("insert", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class batch_insert implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				batch_insert_args args = new batch_insert_args();
				args.read(iprot);
				iprot.readMessageEnd();
				batch_insert_result result = new batch_insert_result();
				try {
					iface_.batch_insert(args.keyspace, args.key, args.cfmap, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing batch_insert", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert");
					oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class remove implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				remove_args args = new remove_args();
				args.read(iprot);
				iprot.readMessageEnd();
				remove_result result = new remove_result();
				try {
					iface_.remove(args.keyspace, args.key, args.column_path, args.timestamp, args.consistency_level);
				} catch (InvalidRequestException ire) {
					result.ire = ire;
				} catch (UnavailableException ue) {
					result.ue = ue;
				} catch (TimedOutException te) {
					result.te = te;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing remove", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing remove");
					oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class get_string_property implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				get_string_property_args args = new get_string_property_args();
				args.read(iprot);
				iprot.readMessageEnd();
				get_string_property_result result = new get_string_property_result();
				result.success = iface_.get_string_property(args.property);
				oprot.writeMessageBegin(new TMessage("get_string_property", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class get_string_list_property implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				get_string_list_property_args args = new get_string_list_property_args();
				args.read(iprot);
				iprot.readMessageEnd();
				get_string_list_property_result result = new get_string_list_property_result();
				result.success = iface_.get_string_list_property(args.property);
				oprot.writeMessageBegin(new TMessage("get_string_list_property", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

		private class describe_keyspace implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				describe_keyspace_args args = new describe_keyspace_args();
				args.read(iprot);
				iprot.readMessageEnd();
				describe_keyspace_result result = new describe_keyspace_result();
				try {
					result.success = iface_.describe_keyspace(args.keyspace);
				} catch (NotFoundException nfe) {
					result.nfe = nfe;
				} catch (Throwable th) {
					LOGGER.error("Internal error processing describe_keyspace", th);
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing describe_keyspace");
					oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

	}

	public static class get_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_args> {
		/**
	 * 
	 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short) 2);
		private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short) 3);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 4);

		public String keyspace;
		public String key;
		public ColumnPath column_path;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEY = 2;
		public static final int COLUMN_PATH = 3;
		public static final int CONSISTENCY_LEVEL = 4;

		// isset id assignments
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
		private BitSet __isset_bit_vector = new BitSet(1);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
		 * 
		 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnPath.class)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
		}

		public get_args() {
			this.consistency_level = 1;

		}

		public get_args(String keyspace, String key, ColumnPath column_path, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.key = key;
			this.column_path = column_path;
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_args(get_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKey()) {
				this.key = other.key;
			}
			if (other.isSetColumn_path()) {
				this.column_path = new ColumnPath(other.column_path);
			}
			this.consistency_level = other.consistency_level;
		}

		public get_args deepCopy() {
			return new get_args(this);
		}

		@Deprecated
		public get_args clone() {
			return new get_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public get_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public String getKey() {
			return this.key;
		}

		public get_args setKey(String key) {
			this.key = key;
			return this;
		}

		public void unsetKey() {
			this.key = null;
		}

		// Returns true if field key is set (has been asigned a value) and false
		// otherwise
		public boolean isSetKey() {
			return this.key != null;
		}

		public void setKeyIsSet(boolean value) {
			if (!value) {
				this.key = null;
			}
		}

		public ColumnPath getColumn_path() {
			return this.column_path;
		}

		public get_args setColumn_path(ColumnPath column_path) {
			this.column_path = column_path;
			return this;
		}

		public void unsetColumn_path() {
			this.column_path = null;
		}

		// Returns true if field column_path is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_path() {
			return this.column_path != null;
		}

		public void setColumn_pathIsSet(boolean value) {
			if (!value) {
				this.column_path = null;
			}
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public get_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEY:
				if (value == null) {
					unsetKey();
				} else {
					setKey((String) value);
				}
				break;

			case COLUMN_PATH:
				if (value == null) {
					unsetColumn_path();
				} else {
					setColumn_path((ColumnPath) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEY:
				return getKey();

			case COLUMN_PATH:
				return getColumn_path();

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEY:
				return isSetKey();
			case COLUMN_PATH:
				return isSetColumn_path();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_args)
				return this.equals((get_args) that);
			return false;
		}

		public boolean equals(get_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_key = true && this.isSetKey();
			boolean that_present_key = true && that.isSetKey();
			if (this_present_key || that_present_key) {
				if (!(this_present_key && that_present_key))
					return false;
				if (!this.key.equals(that.key))
					return false;
			}

			boolean this_present_column_path = true && this.isSetColumn_path();
			boolean that_present_column_path = true && that.isSetColumn_path();
			if (this_present_column_path || that_present_column_path) {
				if (!(this_present_column_path && that_present_column_path))
					return false;
				if (!this.column_path.equals(that.column_path))
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_args typedOther = (get_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(key, typedOther.key);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEY:
					if (field.type == TType.STRING) {
						this.key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PATH:
					if (field.type == TType.STRUCT) {
						this.column_path = new ColumnPath();
						this.column_path.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.key != null) {
				oprot.writeFieldBegin(KEY_FIELD_DESC);
				oprot.writeString(this.key);
				oprot.writeFieldEnd();
			}
			if (this.column_path != null) {
				oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
				this.column_path.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("key:");
			if (this.key == null) {
				sb.append("null");
			} else {
				sb.append(this.key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_path:");
			if (this.column_path == null) {
				sb.append("null");
			} else {
				sb.append(this.column_path);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (key == null) {
				throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
			}
			if (column_path == null) {
				throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class get_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_result> {
		private static final long serialVersionUID = 1L;
		
		private static final TStruct STRUCT_DESC = new TStruct("get_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short) 0);
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short) 2);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 3);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 4);

		public ColumnOrSuperColumn success;
		public InvalidRequestException ire;
		public NotFoundException nfe;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int SUCCESS = 0;
		public static final int IRE = 1;
		public static final int NFE = 2;
		public static final int UE = 3;
		public static final int TE = 4;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)));
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
		}

		public get_result() {
		}

		public get_result(ColumnOrSuperColumn success, InvalidRequestException ire, NotFoundException nfe, UnavailableException ue, TimedOutException te) {
			this();
			this.success = success;
			this.ire = ire;
			this.nfe = nfe;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_result(get_result other) {
			if (other.isSetSuccess()) {
				this.success = new ColumnOrSuperColumn(other.success);
			}
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetNfe()) {
				this.nfe = new NotFoundException(other.nfe);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public get_result deepCopy() {
			return new get_result(this);
		}

		@Deprecated
		public get_result clone() {
			return new get_result(this);
		}

		public ColumnOrSuperColumn getSuccess() {
			return this.success;
		}

		public get_result setSuccess(ColumnOrSuperColumn success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public get_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public NotFoundException getNfe() {
			return this.nfe;
		}

		public get_result setNfe(NotFoundException nfe) {
			this.nfe = nfe;
			return this;
		}

		public void unsetNfe() {
			this.nfe = null;
		}

		// Returns true if field nfe is set (has been asigned a value) and false
		// otherwise
		public boolean isSetNfe() {
			return this.nfe != null;
		}

		public void setNfeIsSet(boolean value) {
			if (!value) {
				this.nfe = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public get_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public get_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((ColumnOrSuperColumn) value);
				}
				break;

			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case NFE:
				if (value == null) {
					unsetNfe();
				} else {
					setNfe((NotFoundException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			case IRE:
				return getIre();

			case NFE:
				return getNfe();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case IRE:
				return isSetIre();
			case NFE:
				return isSetNfe();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_result)
				return this.equals((get_result) that);
			return false;
		}

		public boolean equals(get_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_nfe = true && this.isSetNfe();
			boolean that_present_nfe = true && that.isSetNfe();
			if (this_present_nfe || that_present_nfe) {
				if (!(this_present_nfe && that_present_nfe))
					return false;
				if (!this.nfe.equals(that.nfe))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_result typedOther = (get_result) other;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(success, typedOther.success);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetNfe()).compareTo(isSetNfe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(nfe, typedOther.nfe);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.STRUCT) {
						this.success = new ColumnOrSuperColumn();
						this.success.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case NFE:
					if (field.type == TType.STRUCT) {
						this.nfe = new NotFoundException();
						this.nfe.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				this.success.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetNfe()) {
				oprot.writeFieldBegin(NFE_FIELD_DESC);
				this.nfe.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("nfe:");
			if (this.nfe == null) {
				sb.append("null");
			} else {
				sb.append(this.nfe);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class get_slice_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_slice_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_slice_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short) 2);
		private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short) 3);
		private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short) 4);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 5);

		public String keyspace;
		public String key;
		public ColumnParent column_parent;
		public SlicePredicate predicate;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEY = 2;
		public static final int COLUMN_PARENT = 3;
		public static final int PREDICATE = 4;
		public static final int CONSISTENCY_LEVEL = 5;

		// isset id assignments
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
		private BitSet __isset_bit_vector = new BitSet(1);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnParent.class)));
				put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, SlicePredicate.class)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_slice_args.class, metaDataMap);
		}

		public get_slice_args() {
			this.consistency_level = 1;

		}

		public get_slice_args(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.key = key;
			this.column_parent = column_parent;
			this.predicate = predicate;
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_slice_args(get_slice_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKey()) {
				this.key = other.key;
			}
			if (other.isSetColumn_parent()) {
				this.column_parent = new ColumnParent(other.column_parent);
			}
			if (other.isSetPredicate()) {
				this.predicate = new SlicePredicate(other.predicate);
			}
			this.consistency_level = other.consistency_level;
		}

		public get_slice_args deepCopy() {
			return new get_slice_args(this);
		}

		@Deprecated
		public get_slice_args clone() {
			return new get_slice_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public get_slice_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public String getKey() {
			return this.key;
		}

		public get_slice_args setKey(String key) {
			this.key = key;
			return this;
		}

		public void unsetKey() {
			this.key = null;
		}

		// Returns true if field key is set (has been asigned a value) and false
		// otherwise
		public boolean isSetKey() {
			return this.key != null;
		}

		public void setKeyIsSet(boolean value) {
			if (!value) {
				this.key = null;
			}
		}

		public ColumnParent getColumn_parent() {
			return this.column_parent;
		}

		public get_slice_args setColumn_parent(ColumnParent column_parent) {
			this.column_parent = column_parent;
			return this;
		}

		public void unsetColumn_parent() {
			this.column_parent = null;
		}

		// Returns true if field column_parent is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_parent() {
			return this.column_parent != null;
		}

		public void setColumn_parentIsSet(boolean value) {
			if (!value) {
				this.column_parent = null;
			}
		}

		public SlicePredicate getPredicate() {
			return this.predicate;
		}

		public get_slice_args setPredicate(SlicePredicate predicate) {
			this.predicate = predicate;
			return this;
		}

		public void unsetPredicate() {
			this.predicate = null;
		}

		// Returns true if field predicate is set (has been asigned a value) and
		// false otherwise
		public boolean isSetPredicate() {
			return this.predicate != null;
		}

		public void setPredicateIsSet(boolean value) {
			if (!value) {
				this.predicate = null;
			}
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public get_slice_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEY:
				if (value == null) {
					unsetKey();
				} else {
					setKey((String) value);
				}
				break;

			case COLUMN_PARENT:
				if (value == null) {
					unsetColumn_parent();
				} else {
					setColumn_parent((ColumnParent) value);
				}
				break;

			case PREDICATE:
				if (value == null) {
					unsetPredicate();
				} else {
					setPredicate((SlicePredicate) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEY:
				return getKey();

			case COLUMN_PARENT:
				return getColumn_parent();

			case PREDICATE:
				return getPredicate();

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEY:
				return isSetKey();
			case COLUMN_PARENT:
				return isSetColumn_parent();
			case PREDICATE:
				return isSetPredicate();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_slice_args)
				return this.equals((get_slice_args) that);
			return false;
		}

		public boolean equals(get_slice_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_key = true && this.isSetKey();
			boolean that_present_key = true && that.isSetKey();
			if (this_present_key || that_present_key) {
				if (!(this_present_key && that_present_key))
					return false;
				if (!this.key.equals(that.key))
					return false;
			}

			boolean this_present_column_parent = true && this.isSetColumn_parent();
			boolean that_present_column_parent = true && that.isSetColumn_parent();
			if (this_present_column_parent || that_present_column_parent) {
				if (!(this_present_column_parent && that_present_column_parent))
					return false;
				if (!this.column_parent.equals(that.column_parent))
					return false;
			}

			boolean this_present_predicate = true && this.isSetPredicate();
			boolean that_present_predicate = true && that.isSetPredicate();
			if (this_present_predicate || that_present_predicate) {
				if (!(this_present_predicate && that_present_predicate))
					return false;
				if (!this.predicate.equals(that.predicate))
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_slice_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_slice_args typedOther = (get_slice_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(key, typedOther.key);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(isSetPredicate());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEY:
					if (field.type == TType.STRING) {
						this.key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PARENT:
					if (field.type == TType.STRUCT) {
						this.column_parent = new ColumnParent();
						this.column_parent.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case PREDICATE:
					if (field.type == TType.STRUCT) {
						this.predicate = new SlicePredicate();
						this.predicate.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.key != null) {
				oprot.writeFieldBegin(KEY_FIELD_DESC);
				oprot.writeString(this.key);
				oprot.writeFieldEnd();
			}
			if (this.column_parent != null) {
				oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
				this.column_parent.write(oprot);
				oprot.writeFieldEnd();
			}
			if (this.predicate != null) {
				oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
				this.predicate.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_slice_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("key:");
			if (this.key == null) {
				sb.append("null");
			} else {
				sb.append(this.key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_parent:");
			if (this.column_parent == null) {
				sb.append("null");
			} else {
				sb.append(this.column_parent);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("predicate:");
			if (this.predicate == null) {
				sb.append("null");
			} else {
				sb.append(this.predicate);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (key == null) {
				throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
			}
			if (column_parent == null) {
				throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
			}
			if (predicate == null) {
				throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class get_slice_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_slice_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_slice_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short) 0);
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public List<ColumnOrSuperColumn> success;
		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int SUCCESS = 0;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new ListMetaData(TType.LIST, new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_slice_result.class, metaDataMap);
		}

		public get_slice_result() {
		}

		public get_slice_result(List<ColumnOrSuperColumn> success, InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.success = success;
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_slice_result(get_slice_result other) {
			if (other.isSetSuccess()) {
				List<ColumnOrSuperColumn> __this__success = new ArrayList<ColumnOrSuperColumn>();
				for (ColumnOrSuperColumn other_element : other.success) {
					__this__success.add(new ColumnOrSuperColumn(other_element));
				}
				this.success = __this__success;
			}
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public get_slice_result deepCopy() {
			return new get_slice_result(this);
		}

		@Deprecated
		public get_slice_result clone() {
			return new get_slice_result(this);
		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public java.util.Iterator<ColumnOrSuperColumn> getSuccessIterator() {
			return (this.success == null) ? null : this.success.iterator();
		}

		public void addToSuccess(ColumnOrSuperColumn elem) {
			if (this.success == null) {
				this.success = new ArrayList<ColumnOrSuperColumn>();
			}
			this.success.add(elem);
		}

		public List<ColumnOrSuperColumn> getSuccess() {
			return this.success;
		}

		public get_slice_result setSuccess(List<ColumnOrSuperColumn> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public get_slice_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public get_slice_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public get_slice_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((List<ColumnOrSuperColumn>) value);
				}
				break;

			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_slice_result)
				return this.equals((get_slice_result) that);
			return false;
		}

		public boolean equals(get_slice_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_slice_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_slice_result typedOther = (get_slice_result) other;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(success, typedOther.success);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.LIST) {
						{
							TList _list12 = iprot.readListBegin();
							this.success = new ArrayList<ColumnOrSuperColumn>(_list12.size);
							for (int _i13 = 0; _i13 < _list12.size; ++_i13) {
								ColumnOrSuperColumn _elem14;
								_elem14 = new ColumnOrSuperColumn();
								_elem14.read(iprot);
								this.success.add(_elem14);
							}
							iprot.readListEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				{
					oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
					for (ColumnOrSuperColumn _iter15 : this.success) {
						_iter15.write(oprot);
					}
					oprot.writeListEnd();
				}
				oprot.writeFieldEnd();
			} else if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_slice_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class multiget_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiget_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("multiget_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short) 2);
		private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short) 3);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 4);

		public String keyspace;
		public List<String> keys;
		public ColumnPath column_path;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEYS = 2;
		public static final int COLUMN_PATH = 3;
		public static final int CONSISTENCY_LEVEL = 4;

		// isset id assignments
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
		private BitSet __isset_bit_vector = new BitSet(1);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEYS, new FieldMetaData("keys", TFieldRequirementType.REQUIRED, new ListMetaData(TType.LIST, new FieldValueMetaData(TType.STRING))));
				put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnPath.class)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(multiget_args.class, metaDataMap);
		}

		public multiget_args() {
			this.consistency_level = 1;

		}

		public multiget_args(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.keys = keys;
			this.column_path = column_path;
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public multiget_args(multiget_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKeys()) {
				List<String> __this__keys = new ArrayList<String>();
				for (String other_element : other.keys) {
					__this__keys.add(other_element);
				}
				this.keys = __this__keys;
			}
			if (other.isSetColumn_path()) {
				this.column_path = new ColumnPath(other.column_path);
			}
			this.consistency_level = other.consistency_level;
		}

		public multiget_args deepCopy() {
			return new multiget_args(this);
		}

		@Deprecated
		public multiget_args clone() {
			return new multiget_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public multiget_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public int getKeysSize() {
			return (this.keys == null) ? 0 : this.keys.size();
		}

		public java.util.Iterator<String> getKeysIterator() {
			return (this.keys == null) ? null : this.keys.iterator();
		}

		public void addToKeys(String elem) {
			if (this.keys == null) {
				this.keys = new ArrayList<String>();
			}
			this.keys.add(elem);
		}

		public List<String> getKeys() {
			return this.keys;
		}

		public multiget_args setKeys(List<String> keys) {
			this.keys = keys;
			return this;
		}

		public void unsetKeys() {
			this.keys = null;
		}

		// Returns true if field keys is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeys() {
			return this.keys != null;
		}

		public void setKeysIsSet(boolean value) {
			if (!value) {
				this.keys = null;
			}
		}

		public ColumnPath getColumn_path() {
			return this.column_path;
		}

		public multiget_args setColumn_path(ColumnPath column_path) {
			this.column_path = column_path;
			return this;
		}

		public void unsetColumn_path() {
			this.column_path = null;
		}

		// Returns true if field column_path is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_path() {
			return this.column_path != null;
		}

		public void setColumn_pathIsSet(boolean value) {
			if (!value) {
				this.column_path = null;
			}
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public multiget_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEYS:
				if (value == null) {
					unsetKeys();
				} else {
					setKeys((List<String>) value);
				}
				break;

			case COLUMN_PATH:
				if (value == null) {
					unsetColumn_path();
				} else {
					setColumn_path((ColumnPath) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEYS:
				return getKeys();

			case COLUMN_PATH:
				return getColumn_path();

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEYS:
				return isSetKeys();
			case COLUMN_PATH:
				return isSetColumn_path();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof multiget_args)
				return this.equals((multiget_args) that);
			return false;
		}

		public boolean equals(multiget_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_keys = true && this.isSetKeys();
			boolean that_present_keys = true && that.isSetKeys();
			if (this_present_keys || that_present_keys) {
				if (!(this_present_keys && that_present_keys))
					return false;
				if (!this.keys.equals(that.keys))
					return false;
			}

			boolean this_present_column_path = true && this.isSetColumn_path();
			boolean that_present_column_path = true && that.isSetColumn_path();
			if (this_present_column_path || that_present_column_path) {
				if (!(this_present_column_path && that_present_column_path))
					return false;
				if (!this.column_path.equals(that.column_path))
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(multiget_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			multiget_args typedOther = (multiget_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetKeys()).compareTo(isSetKeys());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEYS:
					if (field.type == TType.LIST) {
						{
							TList _list16 = iprot.readListBegin();
							this.keys = new ArrayList<String>(_list16.size);
							for (int _i17 = 0; _i17 < _list16.size; ++_i17) {
								String _elem18;
								_elem18 = iprot.readString();
								this.keys.add(_elem18);
							}
							iprot.readListEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PATH:
					if (field.type == TType.STRUCT) {
						this.column_path = new ColumnPath();
						this.column_path.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.keys != null) {
				oprot.writeFieldBegin(KEYS_FIELD_DESC);
				{
					oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
					for (String _iter19 : this.keys) {
						oprot.writeString(_iter19);
					}
					oprot.writeListEnd();
				}
				oprot.writeFieldEnd();
			}
			if (this.column_path != null) {
				oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
				this.column_path.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("multiget_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("keys:");
			if (this.keys == null) {
				sb.append("null");
			} else {
				sb.append(this.keys);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_path:");
			if (this.column_path == null) {
				sb.append("null");
			} else {
				sb.append(this.column_path);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (keys == null) {
				throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
			}
			if (column_path == null) {
				throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class multiget_result implements TBase, java.io.Serializable, Cloneable {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("multiget_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short) 0);
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public Map<String, ColumnOrSuperColumn> success;
		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int SUCCESS = 0;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new MapMetaData(TType.MAP, new FieldValueMetaData(TType.STRING), new StructMetaData(TType.STRUCT,
						ColumnOrSuperColumn.class))));
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(multiget_result.class, metaDataMap);
		}

		public multiget_result() {
		}

		public multiget_result(Map<String, ColumnOrSuperColumn> success, InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.success = success;
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public multiget_result(multiget_result other) {
			if (other.isSetSuccess()) {
				Map<String, ColumnOrSuperColumn> __this__success = new HashMap<String, ColumnOrSuperColumn>();
				for (Map.Entry<String, ColumnOrSuperColumn> other_element : other.success.entrySet()) {

					String other_element_key = other_element.getKey();
					ColumnOrSuperColumn other_element_value = other_element.getValue();

					String __this__success_copy_key = other_element_key;

					ColumnOrSuperColumn __this__success_copy_value = new ColumnOrSuperColumn(other_element_value);

					__this__success.put(__this__success_copy_key, __this__success_copy_value);
				}
				this.success = __this__success;
			}
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public multiget_result deepCopy() {
			return new multiget_result(this);
		}

		@Deprecated
		public multiget_result clone() {
			return new multiget_result(this);
		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public void putToSuccess(String key, ColumnOrSuperColumn val) {
			if (this.success == null) {
				this.success = new HashMap<String, ColumnOrSuperColumn>();
			}
			this.success.put(key, val);
		}

		public Map<String, ColumnOrSuperColumn> getSuccess() {
			return this.success;
		}

		public multiget_result setSuccess(Map<String, ColumnOrSuperColumn> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public multiget_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public multiget_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public multiget_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Map<String, ColumnOrSuperColumn>) value);
				}
				break;

			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof multiget_result)
				return this.equals((multiget_result) that);
			return false;
		}

		public boolean equals(multiget_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.MAP) {
						{
							TMap _map20 = iprot.readMapBegin();
							this.success = new HashMap<String, ColumnOrSuperColumn>(2 * _map20.size);
							for (int _i21 = 0; _i21 < _map20.size; ++_i21) {
								String _key22;
								ColumnOrSuperColumn _val23;
								_key22 = iprot.readString();
								_val23 = new ColumnOrSuperColumn();
								_val23.read(iprot);
								this.success.put(_key22, _val23);
							}
							iprot.readMapEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				{
					oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
					for (Map.Entry<String, ColumnOrSuperColumn> _iter24 : this.success.entrySet()) {
						oprot.writeString(_iter24.getKey());
						_iter24.getValue().write(oprot);
					}
					oprot.writeMapEnd();
				}
				oprot.writeFieldEnd();
			} else if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("multiget_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class multiget_slice_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiget_slice_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short) 2);
		private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short) 3);
		private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short) 4);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 5);

		public String keyspace;
		public List<String> keys;
		public ColumnParent column_parent;
		public SlicePredicate predicate;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEYS = 2;
		public static final int COLUMN_PARENT = 3;
		public static final int PREDICATE = 4;
		public static final int CONSISTENCY_LEVEL = 5;

		// isset id assignments
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
		private BitSet __isset_bit_vector = new BitSet(1);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEYS, new FieldMetaData("keys", TFieldRequirementType.REQUIRED, new ListMetaData(TType.LIST, new FieldValueMetaData(TType.STRING))));
				put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnParent.class)));
				put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, SlicePredicate.class)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(multiget_slice_args.class, metaDataMap);
		}

		public multiget_slice_args() {
			this.consistency_level = 1;

		}

		public multiget_slice_args(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.keys = keys;
			this.column_parent = column_parent;
			this.predicate = predicate;
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public multiget_slice_args(multiget_slice_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKeys()) {
				List<String> __this__keys = new ArrayList<String>();
				for (String other_element : other.keys) {
					__this__keys.add(other_element);
				}
				this.keys = __this__keys;
			}
			if (other.isSetColumn_parent()) {
				this.column_parent = new ColumnParent(other.column_parent);
			}
			if (other.isSetPredicate()) {
				this.predicate = new SlicePredicate(other.predicate);
			}
			this.consistency_level = other.consistency_level;
		}

		public multiget_slice_args deepCopy() {
			return new multiget_slice_args(this);
		}

		@Deprecated
		public multiget_slice_args clone() {
			return new multiget_slice_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public multiget_slice_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public int getKeysSize() {
			return (this.keys == null) ? 0 : this.keys.size();
		}

		public java.util.Iterator<String> getKeysIterator() {
			return (this.keys == null) ? null : this.keys.iterator();
		}

		public void addToKeys(String elem) {
			if (this.keys == null) {
				this.keys = new ArrayList<String>();
			}
			this.keys.add(elem);
		}

		public List<String> getKeys() {
			return this.keys;
		}

		public multiget_slice_args setKeys(List<String> keys) {
			this.keys = keys;
			return this;
		}

		public void unsetKeys() {
			this.keys = null;
		}

		// Returns true if field keys is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeys() {
			return this.keys != null;
		}

		public void setKeysIsSet(boolean value) {
			if (!value) {
				this.keys = null;
			}
		}

		public ColumnParent getColumn_parent() {
			return this.column_parent;
		}

		public multiget_slice_args setColumn_parent(ColumnParent column_parent) {
			this.column_parent = column_parent;
			return this;
		}

		public void unsetColumn_parent() {
			this.column_parent = null;
		}

		// Returns true if field column_parent is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_parent() {
			return this.column_parent != null;
		}

		public void setColumn_parentIsSet(boolean value) {
			if (!value) {
				this.column_parent = null;
			}
		}

		public SlicePredicate getPredicate() {
			return this.predicate;
		}

		public multiget_slice_args setPredicate(SlicePredicate predicate) {
			this.predicate = predicate;
			return this;
		}

		public void unsetPredicate() {
			this.predicate = null;
		}

		// Returns true if field predicate is set (has been asigned a value) and
		// false otherwise
		public boolean isSetPredicate() {
			return this.predicate != null;
		}

		public void setPredicateIsSet(boolean value) {
			if (!value) {
				this.predicate = null;
			}
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public multiget_slice_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEYS:
				if (value == null) {
					unsetKeys();
				} else {
					setKeys((List<String>) value);
				}
				break;

			case COLUMN_PARENT:
				if (value == null) {
					unsetColumn_parent();
				} else {
					setColumn_parent((ColumnParent) value);
				}
				break;

			case PREDICATE:
				if (value == null) {
					unsetPredicate();
				} else {
					setPredicate((SlicePredicate) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEYS:
				return getKeys();

			case COLUMN_PARENT:
				return getColumn_parent();

			case PREDICATE:
				return getPredicate();

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEYS:
				return isSetKeys();
			case COLUMN_PARENT:
				return isSetColumn_parent();
			case PREDICATE:
				return isSetPredicate();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof multiget_slice_args)
				return this.equals((multiget_slice_args) that);
			return false;
		}

		public boolean equals(multiget_slice_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_keys = true && this.isSetKeys();
			boolean that_present_keys = true && that.isSetKeys();
			if (this_present_keys || that_present_keys) {
				if (!(this_present_keys && that_present_keys))
					return false;
				if (!this.keys.equals(that.keys))
					return false;
			}

			boolean this_present_column_parent = true && this.isSetColumn_parent();
			boolean that_present_column_parent = true && that.isSetColumn_parent();
			if (this_present_column_parent || that_present_column_parent) {
				if (!(this_present_column_parent && that_present_column_parent))
					return false;
				if (!this.column_parent.equals(that.column_parent))
					return false;
			}

			boolean this_present_predicate = true && this.isSetPredicate();
			boolean that_present_predicate = true && that.isSetPredicate();
			if (this_present_predicate || that_present_predicate) {
				if (!(this_present_predicate && that_present_predicate))
					return false;
				if (!this.predicate.equals(that.predicate))
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(multiget_slice_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			multiget_slice_args typedOther = (multiget_slice_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetKeys()).compareTo(isSetKeys());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(isSetPredicate());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEYS:
					if (field.type == TType.LIST) {
						{
							TList _list25 = iprot.readListBegin();
							this.keys = new ArrayList<String>(_list25.size);
							for (int _i26 = 0; _i26 < _list25.size; ++_i26) {
								String _elem27;
								_elem27 = iprot.readString();
								this.keys.add(_elem27);
							}
							iprot.readListEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PARENT:
					if (field.type == TType.STRUCT) {
						this.column_parent = new ColumnParent();
						this.column_parent.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case PREDICATE:
					if (field.type == TType.STRUCT) {
						this.predicate = new SlicePredicate();
						this.predicate.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.keys != null) {
				oprot.writeFieldBegin(KEYS_FIELD_DESC);
				{
					oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
					for (String _iter28 : this.keys) {
						oprot.writeString(_iter28);
					}
					oprot.writeListEnd();
				}
				oprot.writeFieldEnd();
			}
			if (this.column_parent != null) {
				oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
				this.column_parent.write(oprot);
				oprot.writeFieldEnd();
			}
			if (this.predicate != null) {
				oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
				this.predicate.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("multiget_slice_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("keys:");
			if (this.keys == null) {
				sb.append("null");
			} else {
				sb.append(this.keys);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_parent:");
			if (this.column_parent == null) {
				sb.append("null");
			} else {
				sb.append(this.column_parent);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("predicate:");
			if (this.predicate == null) {
				sb.append("null");
			} else {
				sb.append(this.predicate);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (keys == null) {
				throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
			}
			if (column_parent == null) {
				throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
			}
			if (predicate == null) {
				throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class multiget_slice_result implements TBase, java.io.Serializable, Cloneable {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short) 0);
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public Map<String, List<ColumnOrSuperColumn>> success;
		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int SUCCESS = 0;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new MapMetaData(TType.MAP, new FieldValueMetaData(TType.STRING), new ListMetaData(TType.LIST,
						new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)))));
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(multiget_slice_result.class, metaDataMap);
		}

		public multiget_slice_result() {
		}

		public multiget_slice_result(Map<String, List<ColumnOrSuperColumn>> success, InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.success = success;
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public multiget_slice_result(multiget_slice_result other) {
			if (other.isSetSuccess()) {
				Map<String, List<ColumnOrSuperColumn>> __this__success = new HashMap<String, List<ColumnOrSuperColumn>>();
				for (Map.Entry<String, List<ColumnOrSuperColumn>> other_element : other.success.entrySet()) {

					String other_element_key = other_element.getKey();
					List<ColumnOrSuperColumn> other_element_value = other_element.getValue();

					String __this__success_copy_key = other_element_key;

					List<ColumnOrSuperColumn> __this__success_copy_value = new ArrayList<ColumnOrSuperColumn>();
					for (ColumnOrSuperColumn other_element_value_element : other_element_value) {
						__this__success_copy_value.add(new ColumnOrSuperColumn(other_element_value_element));
					}

					__this__success.put(__this__success_copy_key, __this__success_copy_value);
				}
				this.success = __this__success;
			}
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public multiget_slice_result deepCopy() {
			return new multiget_slice_result(this);
		}

		@Deprecated
		public multiget_slice_result clone() {
			return new multiget_slice_result(this);
		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public void putToSuccess(String key, List<ColumnOrSuperColumn> val) {
			if (this.success == null) {
				this.success = new HashMap<String, List<ColumnOrSuperColumn>>();
			}
			this.success.put(key, val);
		}

		public Map<String, List<ColumnOrSuperColumn>> getSuccess() {
			return this.success;
		}

		public multiget_slice_result setSuccess(Map<String, List<ColumnOrSuperColumn>> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public multiget_slice_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public multiget_slice_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public multiget_slice_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Map<String, List<ColumnOrSuperColumn>>) value);
				}
				break;

			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof multiget_slice_result)
				return this.equals((multiget_slice_result) that);
			return false;
		}

		public boolean equals(multiget_slice_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.MAP) {
						{
							TMap _map29 = iprot.readMapBegin();
							this.success = new HashMap<String, List<ColumnOrSuperColumn>>(2 * _map29.size);
							for (int _i30 = 0; _i30 < _map29.size; ++_i30) {
								String _key31;
								List<ColumnOrSuperColumn> _val32;
								_key31 = iprot.readString();
								{
									TList _list33 = iprot.readListBegin();
									_val32 = new ArrayList<ColumnOrSuperColumn>(_list33.size);
									for (int _i34 = 0; _i34 < _list33.size; ++_i34) {
										ColumnOrSuperColumn _elem35;
										_elem35 = new ColumnOrSuperColumn();
										_elem35.read(iprot);
										_val32.add(_elem35);
									}
									iprot.readListEnd();
								}
								this.success.put(_key31, _val32);
							}
							iprot.readMapEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				{
					oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
					for (Map.Entry<String, List<ColumnOrSuperColumn>> _iter36 : this.success.entrySet()) {
						oprot.writeString(_iter36.getKey());
						{
							oprot.writeListBegin(new TList(TType.STRUCT, _iter36.getValue().size()));
							for (ColumnOrSuperColumn _iter37 : _iter36.getValue()) {
								_iter37.write(oprot);
							}
							oprot.writeListEnd();
						}
					}
					oprot.writeMapEnd();
				}
				oprot.writeFieldEnd();
			} else if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("multiget_slice_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class get_count_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_count_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short) 2);
		private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short) 3);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 4);

		public String keyspace;
		public String key;
		public ColumnParent column_parent;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEY = 2;
		public static final int COLUMN_PARENT = 3;
		public static final int CONSISTENCY_LEVEL = 4;

		// isset id assignments
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
		private BitSet __isset_bit_vector = new BitSet(1);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnParent.class)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_count_args.class, metaDataMap);
		}

		public get_count_args() {
			this.consistency_level = 1;

		}

		public get_count_args(String keyspace, String key, ColumnParent column_parent, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.key = key;
			this.column_parent = column_parent;
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_count_args(get_count_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKey()) {
				this.key = other.key;
			}
			if (other.isSetColumn_parent()) {
				this.column_parent = new ColumnParent(other.column_parent);
			}
			this.consistency_level = other.consistency_level;
		}

		public get_count_args deepCopy() {
			return new get_count_args(this);
		}

		@Deprecated
		public get_count_args clone() {
			return new get_count_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public get_count_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public String getKey() {
			return this.key;
		}

		public get_count_args setKey(String key) {
			this.key = key;
			return this;
		}

		public void unsetKey() {
			this.key = null;
		}

		// Returns true if field key is set (has been asigned a value) and false
		// otherwise
		public boolean isSetKey() {
			return this.key != null;
		}

		public void setKeyIsSet(boolean value) {
			if (!value) {
				this.key = null;
			}
		}

		public ColumnParent getColumn_parent() {
			return this.column_parent;
		}

		public get_count_args setColumn_parent(ColumnParent column_parent) {
			this.column_parent = column_parent;
			return this;
		}

		public void unsetColumn_parent() {
			this.column_parent = null;
		}

		// Returns true if field column_parent is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_parent() {
			return this.column_parent != null;
		}

		public void setColumn_parentIsSet(boolean value) {
			if (!value) {
				this.column_parent = null;
			}
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public get_count_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEY:
				if (value == null) {
					unsetKey();
				} else {
					setKey((String) value);
				}
				break;

			case COLUMN_PARENT:
				if (value == null) {
					unsetColumn_parent();
				} else {
					setColumn_parent((ColumnParent) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEY:
				return getKey();

			case COLUMN_PARENT:
				return getColumn_parent();

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEY:
				return isSetKey();
			case COLUMN_PARENT:
				return isSetColumn_parent();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_count_args)
				return this.equals((get_count_args) that);
			return false;
		}

		public boolean equals(get_count_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_key = true && this.isSetKey();
			boolean that_present_key = true && that.isSetKey();
			if (this_present_key || that_present_key) {
				if (!(this_present_key && that_present_key))
					return false;
				if (!this.key.equals(that.key))
					return false;
			}

			boolean this_present_column_parent = true && this.isSetColumn_parent();
			boolean that_present_column_parent = true && that.isSetColumn_parent();
			if (this_present_column_parent || that_present_column_parent) {
				if (!(this_present_column_parent && that_present_column_parent))
					return false;
				if (!this.column_parent.equals(that.column_parent))
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_count_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_count_args typedOther = (get_count_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(key, typedOther.key);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEY:
					if (field.type == TType.STRING) {
						this.key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PARENT:
					if (field.type == TType.STRUCT) {
						this.column_parent = new ColumnParent();
						this.column_parent.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.key != null) {
				oprot.writeFieldBegin(KEY_FIELD_DESC);
				oprot.writeString(this.key);
				oprot.writeFieldEnd();
			}
			if (this.column_parent != null) {
				oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
				this.column_parent.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_count_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("key:");
			if (this.key == null) {
				sb.append("null");
			} else {
				sb.append(this.key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_parent:");
			if (this.column_parent == null) {
				sb.append("null");
			} else {
				sb.append(this.column_parent);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (key == null) {
				throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
			}
			if (column_parent == null) {
				throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class get_count_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_count_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short) 0);
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public int success;
		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int SUCCESS = 0;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private BitSet __isset_bit_vector = new BitSet(1);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.I32)));
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_count_result.class, metaDataMap);
		}

		public get_count_result() {
		}

		public get_count_result(int success, InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.success = success;
			setSuccessIsSet(true);
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_count_result(get_count_result other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			this.success = other.success;
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public get_count_result deepCopy() {
			return new get_count_result(this);
		}

		@Deprecated
		public get_count_result clone() {
			return new get_count_result(this);
		}

		public int getSuccess() {
			return this.success;
		}

		public get_count_result setSuccess(int success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bit_vector.clear(__SUCCESS_ISSET_ID);
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public get_count_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public get_count_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public get_count_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Integer) value);
				}
				break;

			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return new Integer(getSuccess());

			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_count_result)
				return this.equals((get_count_result) that);
			return false;
		}

		public boolean equals(get_count_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true;
			boolean that_present_success = true;
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (this.success != that.success)
					return false;
			}

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_count_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_count_result typedOther = (get_count_result) other;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(success, typedOther.success);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.I32) {
						this.success = iprot.readI32();
						setSuccessIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				oprot.writeI32(this.success);
				oprot.writeFieldEnd();
			} else if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_count_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class get_key_range_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_key_range_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_key_range_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short) 2);
		private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short) 3);
		private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short) 4);
		private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short) 5);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 6);

		public String keyspace;
		public String column_family;
		public String start;
		public String finish;
		public int count;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int COLUMN_FAMILY = 2;
		public static final int START = 3;
		public static final int FINISH = 4;
		public static final int COUNT = 5;
		public static final int CONSISTENCY_LEVEL = 6;

		// isset id assignments
		private static final int __COUNT_ISSET_ID = 0;
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 1;
		private BitSet __isset_bit_vector = new BitSet(2);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(START, new FieldMetaData("start", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(FINISH, new FieldMetaData("finish", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COUNT, new FieldMetaData("count", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_key_range_args.class, metaDataMap);
		}

		public get_key_range_args() {
			this.start = "";

			this.finish = "";

			this.count = 100;

			this.consistency_level = 1;

		}

		public get_key_range_args(String keyspace, String column_family, String start, String finish, int count, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.column_family = column_family;
			this.start = start;
			this.finish = finish;
			this.count = count;
			setCountIsSet(true);
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_key_range_args(get_key_range_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetColumn_family()) {
				this.column_family = other.column_family;
			}
			if (other.isSetStart()) {
				this.start = other.start;
			}
			if (other.isSetFinish()) {
				this.finish = other.finish;
			}
			this.count = other.count;
			this.consistency_level = other.consistency_level;
		}

		public get_key_range_args deepCopy() {
			return new get_key_range_args(this);
		}

		@Deprecated
		public get_key_range_args clone() {
			return new get_key_range_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public get_key_range_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public String getColumn_family() {
			return this.column_family;
		}

		public get_key_range_args setColumn_family(String column_family) {
			this.column_family = column_family;
			return this;
		}

		public void unsetColumn_family() {
			this.column_family = null;
		}

		// Returns true if field column_family is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_family() {
			return this.column_family != null;
		}

		public void setColumn_familyIsSet(boolean value) {
			if (!value) {
				this.column_family = null;
			}
		}

		public String getStart() {
			return this.start;
		}

		public get_key_range_args setStart(String start) {
			this.start = start;
			return this;
		}

		public void unsetStart() {
			this.start = null;
		}

		// Returns true if field start is set (has been asigned a value) and
		// false otherwise
		public boolean isSetStart() {
			return this.start != null;
		}

		public void setStartIsSet(boolean value) {
			if (!value) {
				this.start = null;
			}
		}

		public String getFinish() {
			return this.finish;
		}

		public get_key_range_args setFinish(String finish) {
			this.finish = finish;
			return this;
		}

		public void unsetFinish() {
			this.finish = null;
		}

		// Returns true if field finish is set (has been asigned a value) and
		// false otherwise
		public boolean isSetFinish() {
			return this.finish != null;
		}

		public void setFinishIsSet(boolean value) {
			if (!value) {
				this.finish = null;
			}
		}

		public int getCount() {
			return this.count;
		}

		public get_key_range_args setCount(int count) {
			this.count = count;
			setCountIsSet(true);
			return this;
		}

		public void unsetCount() {
			__isset_bit_vector.clear(__COUNT_ISSET_ID);
		}

		// Returns true if field count is set (has been asigned a value) and
		// false otherwise
		public boolean isSetCount() {
			return __isset_bit_vector.get(__COUNT_ISSET_ID);
		}

		public void setCountIsSet(boolean value) {
			__isset_bit_vector.set(__COUNT_ISSET_ID, value);
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public get_key_range_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case COLUMN_FAMILY:
				if (value == null) {
					unsetColumn_family();
				} else {
					setColumn_family((String) value);
				}
				break;

			case START:
				if (value == null) {
					unsetStart();
				} else {
					setStart((String) value);
				}
				break;

			case FINISH:
				if (value == null) {
					unsetFinish();
				} else {
					setFinish((String) value);
				}
				break;

			case COUNT:
				if (value == null) {
					unsetCount();
				} else {
					setCount((Integer) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case COLUMN_FAMILY:
				return getColumn_family();

			case START:
				return getStart();

			case FINISH:
				return getFinish();

			case COUNT:
				return new Integer(getCount());

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case COLUMN_FAMILY:
				return isSetColumn_family();
			case START:
				return isSetStart();
			case FINISH:
				return isSetFinish();
			case COUNT:
				return isSetCount();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_key_range_args)
				return this.equals((get_key_range_args) that);
			return false;
		}

		public boolean equals(get_key_range_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_column_family = true && this.isSetColumn_family();
			boolean that_present_column_family = true && that.isSetColumn_family();
			if (this_present_column_family || that_present_column_family) {
				if (!(this_present_column_family && that_present_column_family))
					return false;
				if (!this.column_family.equals(that.column_family))
					return false;
			}

			boolean this_present_start = true && this.isSetStart();
			boolean that_present_start = true && that.isSetStart();
			if (this_present_start || that_present_start) {
				if (!(this_present_start && that_present_start))
					return false;
				if (!this.start.equals(that.start))
					return false;
			}

			boolean this_present_finish = true && this.isSetFinish();
			boolean that_present_finish = true && that.isSetFinish();
			if (this_present_finish || that_present_finish) {
				if (!(this_present_finish && that_present_finish))
					return false;
				if (!this.finish.equals(that.finish))
					return false;
			}

			boolean this_present_count = true;
			boolean that_present_count = true;
			if (this_present_count || that_present_count) {
				if (!(this_present_count && that_present_count))
					return false;
				if (this.count != that.count)
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_key_range_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_key_range_args typedOther = (get_key_range_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_family()).compareTo(isSetColumn_family());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_family, typedOther.column_family);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetStart()).compareTo(isSetStart());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(start, typedOther.start);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetFinish()).compareTo(isSetFinish());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(finish, typedOther.finish);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetCount()).compareTo(isSetCount());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(count, typedOther.count);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_FAMILY:
					if (field.type == TType.STRING) {
						this.column_family = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case START:
					if (field.type == TType.STRING) {
						this.start = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case FINISH:
					if (field.type == TType.STRING) {
						this.finish = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COUNT:
					if (field.type == TType.I32) {
						this.count = iprot.readI32();
						setCountIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetCount()) {
				throw new TProtocolException("Required field 'count' was not found in serialized data! Struct: " + toString());
			}
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.column_family != null) {
				oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
				oprot.writeString(this.column_family);
				oprot.writeFieldEnd();
			}
			if (this.start != null) {
				oprot.writeFieldBegin(START_FIELD_DESC);
				oprot.writeString(this.start);
				oprot.writeFieldEnd();
			}
			if (this.finish != null) {
				oprot.writeFieldBegin(FINISH_FIELD_DESC);
				oprot.writeString(this.finish);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(COUNT_FIELD_DESC);
			oprot.writeI32(this.count);
			oprot.writeFieldEnd();
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_key_range_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_family:");
			if (this.column_family == null) {
				sb.append("null");
			} else {
				sb.append(this.column_family);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("start:");
			if (this.start == null) {
				sb.append("null");
			} else {
				sb.append(this.start);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("finish:");
			if (this.finish == null) {
				sb.append("null");
			} else {
				sb.append(this.finish);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("count:");
			sb.append(this.count);
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (column_family == null) {
				throw new TProtocolException("Required field 'column_family' was not present! Struct: " + toString());
			}
			if (start == null) {
				throw new TProtocolException("Required field 'start' was not present! Struct: " + toString());
			}
			if (finish == null) {
				throw new TProtocolException("Required field 'finish' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'count' because it's a primitive and you
			// chose the non-beans generator.
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class get_key_range_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_key_range_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_key_range_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short) 0);
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public List<String> success;
		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int SUCCESS = 0;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new ListMetaData(TType.LIST, new FieldValueMetaData(TType.STRING))));
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_key_range_result.class, metaDataMap);
		}

		public get_key_range_result() {
		}

		public get_key_range_result(List<String> success, InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.success = success;
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_key_range_result(get_key_range_result other) {
			if (other.isSetSuccess()) {
				List<String> __this__success = new ArrayList<String>();
				for (String other_element : other.success) {
					__this__success.add(other_element);
				}
				this.success = __this__success;
			}
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public get_key_range_result deepCopy() {
			return new get_key_range_result(this);
		}

		@Deprecated
		public get_key_range_result clone() {
			return new get_key_range_result(this);
		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public java.util.Iterator<String> getSuccessIterator() {
			return (this.success == null) ? null : this.success.iterator();
		}

		public void addToSuccess(String elem) {
			if (this.success == null) {
				this.success = new ArrayList<String>();
			}
			this.success.add(elem);
		}

		public List<String> getSuccess() {
			return this.success;
		}

		public get_key_range_result setSuccess(List<String> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public get_key_range_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public get_key_range_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public get_key_range_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((List<String>) value);
				}
				break;

			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_key_range_result)
				return this.equals((get_key_range_result) that);
			return false;
		}

		public boolean equals(get_key_range_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_key_range_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_key_range_result typedOther = (get_key_range_result) other;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(success, typedOther.success);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.LIST) {
						{
							TList _list38 = iprot.readListBegin();
							this.success = new ArrayList<String>(_list38.size);
							for (int _i39 = 0; _i39 < _list38.size; ++_i39) {
								String _elem40;
								_elem40 = iprot.readString();
								this.success.add(_elem40);
							}
							iprot.readListEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				{
					oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
					for (String _iter41 : this.success) {
						oprot.writeString(_iter41);
					}
					oprot.writeListEnd();
				}
				oprot.writeFieldEnd();
			} else if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_key_range_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class get_range_slice_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_range_slice_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_range_slice_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short) 2);
		private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short) 3);
		private static final TField START_KEY_FIELD_DESC = new TField("start_key", TType.STRING, (short) 4);
		private static final TField FINISH_KEY_FIELD_DESC = new TField("finish_key", TType.STRING, (short) 5);
		private static final TField ROW_COUNT_FIELD_DESC = new TField("row_count", TType.I32, (short) 6);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 7);

		public String keyspace;
		public ColumnParent column_parent;
		public SlicePredicate predicate;
		public String start_key;
		public String finish_key;
		public int row_count;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int COLUMN_PARENT = 2;
		public static final int PREDICATE = 3;
		public static final int START_KEY = 4;
		public static final int FINISH_KEY = 5;
		public static final int ROW_COUNT = 6;
		public static final int CONSISTENCY_LEVEL = 7;

		// isset id assignments
		private static final int __ROW_COUNT_ISSET_ID = 0;
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 1;
		private BitSet __isset_bit_vector = new BitSet(2);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnParent.class)));
				put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, SlicePredicate.class)));
				put(START_KEY, new FieldMetaData("start_key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(FINISH_KEY, new FieldMetaData("finish_key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(ROW_COUNT, new FieldMetaData("row_count", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_range_slice_args.class, metaDataMap);
		}

		public get_range_slice_args() {
			this.start_key = "";

			this.finish_key = "";

			this.row_count = 100;

			this.consistency_level = 1;

		}

		public get_range_slice_args(String keyspace, ColumnParent column_parent, SlicePredicate predicate, String start_key, String finish_key, int row_count, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.column_parent = column_parent;
			this.predicate = predicate;
			this.start_key = start_key;
			this.finish_key = finish_key;
			this.row_count = row_count;
			setRow_countIsSet(true);
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_range_slice_args(get_range_slice_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetColumn_parent()) {
				this.column_parent = new ColumnParent(other.column_parent);
			}
			if (other.isSetPredicate()) {
				this.predicate = new SlicePredicate(other.predicate);
			}
			if (other.isSetStart_key()) {
				this.start_key = other.start_key;
			}
			if (other.isSetFinish_key()) {
				this.finish_key = other.finish_key;
			}
			this.row_count = other.row_count;
			this.consistency_level = other.consistency_level;
		}

		public get_range_slice_args deepCopy() {
			return new get_range_slice_args(this);
		}

		@Deprecated
		public get_range_slice_args clone() {
			return new get_range_slice_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public get_range_slice_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public ColumnParent getColumn_parent() {
			return this.column_parent;
		}

		public get_range_slice_args setColumn_parent(ColumnParent column_parent) {
			this.column_parent = column_parent;
			return this;
		}

		public void unsetColumn_parent() {
			this.column_parent = null;
		}

		// Returns true if field column_parent is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_parent() {
			return this.column_parent != null;
		}

		public void setColumn_parentIsSet(boolean value) {
			if (!value) {
				this.column_parent = null;
			}
		}

		public SlicePredicate getPredicate() {
			return this.predicate;
		}

		public get_range_slice_args setPredicate(SlicePredicate predicate) {
			this.predicate = predicate;
			return this;
		}

		public void unsetPredicate() {
			this.predicate = null;
		}

		// Returns true if field predicate is set (has been asigned a value) and
		// false otherwise
		public boolean isSetPredicate() {
			return this.predicate != null;
		}

		public void setPredicateIsSet(boolean value) {
			if (!value) {
				this.predicate = null;
			}
		}

		public String getStart_key() {
			return this.start_key;
		}

		public get_range_slice_args setStart_key(String start_key) {
			this.start_key = start_key;
			return this;
		}

		public void unsetStart_key() {
			this.start_key = null;
		}

		// Returns true if field start_key is set (has been asigned a value) and
		// false otherwise
		public boolean isSetStart_key() {
			return this.start_key != null;
		}

		public void setStart_keyIsSet(boolean value) {
			if (!value) {
				this.start_key = null;
			}
		}

		public String getFinish_key() {
			return this.finish_key;
		}

		public get_range_slice_args setFinish_key(String finish_key) {
			this.finish_key = finish_key;
			return this;
		}

		public void unsetFinish_key() {
			this.finish_key = null;
		}

		// Returns true if field finish_key is set (has been asigned a value)
		// and false otherwise
		public boolean isSetFinish_key() {
			return this.finish_key != null;
		}

		public void setFinish_keyIsSet(boolean value) {
			if (!value) {
				this.finish_key = null;
			}
		}

		public int getRow_count() {
			return this.row_count;
		}

		public get_range_slice_args setRow_count(int row_count) {
			this.row_count = row_count;
			setRow_countIsSet(true);
			return this;
		}

		public void unsetRow_count() {
			__isset_bit_vector.clear(__ROW_COUNT_ISSET_ID);
		}

		// Returns true if field row_count is set (has been asigned a value) and
		// false otherwise
		public boolean isSetRow_count() {
			return __isset_bit_vector.get(__ROW_COUNT_ISSET_ID);
		}

		public void setRow_countIsSet(boolean value) {
			__isset_bit_vector.set(__ROW_COUNT_ISSET_ID, value);
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public get_range_slice_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case COLUMN_PARENT:
				if (value == null) {
					unsetColumn_parent();
				} else {
					setColumn_parent((ColumnParent) value);
				}
				break;

			case PREDICATE:
				if (value == null) {
					unsetPredicate();
				} else {
					setPredicate((SlicePredicate) value);
				}
				break;

			case START_KEY:
				if (value == null) {
					unsetStart_key();
				} else {
					setStart_key((String) value);
				}
				break;

			case FINISH_KEY:
				if (value == null) {
					unsetFinish_key();
				} else {
					setFinish_key((String) value);
				}
				break;

			case ROW_COUNT:
				if (value == null) {
					unsetRow_count();
				} else {
					setRow_count((Integer) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case COLUMN_PARENT:
				return getColumn_parent();

			case PREDICATE:
				return getPredicate();

			case START_KEY:
				return getStart_key();

			case FINISH_KEY:
				return getFinish_key();

			case ROW_COUNT:
				return new Integer(getRow_count());

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case COLUMN_PARENT:
				return isSetColumn_parent();
			case PREDICATE:
				return isSetPredicate();
			case START_KEY:
				return isSetStart_key();
			case FINISH_KEY:
				return isSetFinish_key();
			case ROW_COUNT:
				return isSetRow_count();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_range_slice_args)
				return this.equals((get_range_slice_args) that);
			return false;
		}

		public boolean equals(get_range_slice_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_column_parent = true && this.isSetColumn_parent();
			boolean that_present_column_parent = true && that.isSetColumn_parent();
			if (this_present_column_parent || that_present_column_parent) {
				if (!(this_present_column_parent && that_present_column_parent))
					return false;
				if (!this.column_parent.equals(that.column_parent))
					return false;
			}

			boolean this_present_predicate = true && this.isSetPredicate();
			boolean that_present_predicate = true && that.isSetPredicate();
			if (this_present_predicate || that_present_predicate) {
				if (!(this_present_predicate && that_present_predicate))
					return false;
				if (!this.predicate.equals(that.predicate))
					return false;
			}

			boolean this_present_start_key = true && this.isSetStart_key();
			boolean that_present_start_key = true && that.isSetStart_key();
			if (this_present_start_key || that_present_start_key) {
				if (!(this_present_start_key && that_present_start_key))
					return false;
				if (!this.start_key.equals(that.start_key))
					return false;
			}

			boolean this_present_finish_key = true && this.isSetFinish_key();
			boolean that_present_finish_key = true && that.isSetFinish_key();
			if (this_present_finish_key || that_present_finish_key) {
				if (!(this_present_finish_key && that_present_finish_key))
					return false;
				if (!this.finish_key.equals(that.finish_key))
					return false;
			}

			boolean this_present_row_count = true;
			boolean that_present_row_count = true;
			if (this_present_row_count || that_present_row_count) {
				if (!(this_present_row_count && that_present_row_count))
					return false;
				if (this.row_count != that.row_count)
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_range_slice_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_range_slice_args typedOther = (get_range_slice_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(isSetPredicate());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetStart_key()).compareTo(isSetStart_key());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(start_key, typedOther.start_key);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetFinish_key()).compareTo(isSetFinish_key());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(finish_key, typedOther.finish_key);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetRow_count()).compareTo(isSetRow_count());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(row_count, typedOther.row_count);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PARENT:
					if (field.type == TType.STRUCT) {
						this.column_parent = new ColumnParent();
						this.column_parent.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case PREDICATE:
					if (field.type == TType.STRUCT) {
						this.predicate = new SlicePredicate();
						this.predicate.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case START_KEY:
					if (field.type == TType.STRING) {
						this.start_key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case FINISH_KEY:
					if (field.type == TType.STRING) {
						this.finish_key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case ROW_COUNT:
					if (field.type == TType.I32) {
						this.row_count = iprot.readI32();
						setRow_countIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetRow_count()) {
				throw new TProtocolException("Required field 'row_count' was not found in serialized data! Struct: " + toString());
			}
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.column_parent != null) {
				oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
				this.column_parent.write(oprot);
				oprot.writeFieldEnd();
			}
			if (this.predicate != null) {
				oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
				this.predicate.write(oprot);
				oprot.writeFieldEnd();
			}
			if (this.start_key != null) {
				oprot.writeFieldBegin(START_KEY_FIELD_DESC);
				oprot.writeString(this.start_key);
				oprot.writeFieldEnd();
			}
			if (this.finish_key != null) {
				oprot.writeFieldBegin(FINISH_KEY_FIELD_DESC);
				oprot.writeString(this.finish_key);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(ROW_COUNT_FIELD_DESC);
			oprot.writeI32(this.row_count);
			oprot.writeFieldEnd();
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_range_slice_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_parent:");
			if (this.column_parent == null) {
				sb.append("null");
			} else {
				sb.append(this.column_parent);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("predicate:");
			if (this.predicate == null) {
				sb.append("null");
			} else {
				sb.append(this.predicate);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("start_key:");
			if (this.start_key == null) {
				sb.append("null");
			} else {
				sb.append(this.start_key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("finish_key:");
			if (this.finish_key == null) {
				sb.append("null");
			} else {
				sb.append(this.finish_key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("row_count:");
			sb.append(this.row_count);
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (column_parent == null) {
				throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
			}
			if (predicate == null) {
				throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
			}
			if (start_key == null) {
				throw new TProtocolException("Required field 'start_key' was not present! Struct: " + toString());
			}
			if (finish_key == null) {
				throw new TProtocolException("Required field 'finish_key' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'row_count' because it's a primitive and
			// you chose the non-beans generator.
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class get_range_slice_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_range_slice_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_range_slice_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short) 0);
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public List<KeySlice> success;
		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int SUCCESS = 0;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new ListMetaData(TType.LIST, new StructMetaData(TType.STRUCT, KeySlice.class))));
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_range_slice_result.class, metaDataMap);
		}

		public get_range_slice_result() {
		}

		public get_range_slice_result(List<KeySlice> success, InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.success = success;
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_range_slice_result(get_range_slice_result other) {
			if (other.isSetSuccess()) {
				List<KeySlice> __this__success = new ArrayList<KeySlice>();
				for (KeySlice other_element : other.success) {
					__this__success.add(new KeySlice(other_element));
				}
				this.success = __this__success;
			}
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public get_range_slice_result deepCopy() {
			return new get_range_slice_result(this);
		}

		@Deprecated
		public get_range_slice_result clone() {
			return new get_range_slice_result(this);
		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public java.util.Iterator<KeySlice> getSuccessIterator() {
			return (this.success == null) ? null : this.success.iterator();
		}

		public void addToSuccess(KeySlice elem) {
			if (this.success == null) {
				this.success = new ArrayList<KeySlice>();
			}
			this.success.add(elem);
		}

		public List<KeySlice> getSuccess() {
			return this.success;
		}

		public get_range_slice_result setSuccess(List<KeySlice> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public get_range_slice_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public get_range_slice_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public get_range_slice_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((List<KeySlice>) value);
				}
				break;

			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_range_slice_result)
				return this.equals((get_range_slice_result) that);
			return false;
		}

		public boolean equals(get_range_slice_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_range_slice_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_range_slice_result typedOther = (get_range_slice_result) other;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(success, typedOther.success);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.LIST) {
						{
							TList _list42 = iprot.readListBegin();
							this.success = new ArrayList<KeySlice>(_list42.size);
							for (int _i43 = 0; _i43 < _list42.size; ++_i43) {
								KeySlice _elem44;
								_elem44 = new KeySlice();
								_elem44.read(iprot);
								this.success.add(_elem44);
							}
							iprot.readListEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				{
					oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
					for (KeySlice _iter45 : this.success) {
						_iter45.write(oprot);
					}
					oprot.writeListEnd();
				}
				oprot.writeFieldEnd();
			} else if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_range_slice_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class insert_args implements TBase, java.io.Serializable, Cloneable, Comparable<insert_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("insert_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short) 2);
		private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short) 3);
		private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short) 4);
		private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short) 5);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 6);

		public String keyspace;
		public String key;
		public ColumnPath column_path;
		public byte[] value;
		public long timestamp;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEY = 2;
		public static final int COLUMN_PATH = 3;
		public static final int VALUE = 4;
		public static final int TIMESTAMP = 5;
		public static final int CONSISTENCY_LEVEL = 6;

		// isset id assignments
		private static final int __TIMESTAMP_ISSET_ID = 0;
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 1;
		private BitSet __isset_bit_vector = new BitSet(2);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnPath.class)));
				put(VALUE, new FieldMetaData("value", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I64)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(insert_args.class, metaDataMap);
		}

		public insert_args() {
			this.consistency_level = 0;

		}

		public insert_args(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.key = key;
			this.column_path = column_path;
			this.value = value;
			this.timestamp = timestamp;
			setTimestampIsSet(true);
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public insert_args(insert_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKey()) {
				this.key = other.key;
			}
			if (other.isSetColumn_path()) {
				this.column_path = new ColumnPath(other.column_path);
			}
			if (other.isSetValue()) {
				this.value = new byte[other.value.length];
				System.arraycopy(other.value, 0, value, 0, other.value.length);
			}
			this.timestamp = other.timestamp;
			this.consistency_level = other.consistency_level;
		}

		public insert_args deepCopy() {
			return new insert_args(this);
		}

		@Deprecated
		public insert_args clone() {
			return new insert_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public insert_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public String getKey() {
			return this.key;
		}

		public insert_args setKey(String key) {
			this.key = key;
			return this;
		}

		public void unsetKey() {
			this.key = null;
		}

		// Returns true if field key is set (has been asigned a value) and false
		// otherwise
		public boolean isSetKey() {
			return this.key != null;
		}

		public void setKeyIsSet(boolean value) {
			if (!value) {
				this.key = null;
			}
		}

		public ColumnPath getColumn_path() {
			return this.column_path;
		}

		public insert_args setColumn_path(ColumnPath column_path) {
			this.column_path = column_path;
			return this;
		}

		public void unsetColumn_path() {
			this.column_path = null;
		}

		// Returns true if field column_path is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_path() {
			return this.column_path != null;
		}

		public void setColumn_pathIsSet(boolean value) {
			if (!value) {
				this.column_path = null;
			}
		}

		public byte[] getValue() {
			return this.value;
		}

		public insert_args setValue(byte[] value) {
			this.value = value;
			return this;
		}

		public void unsetValue() {
			this.value = null;
		}

		// Returns true if field value is set (has been asigned a value) and
		// false otherwise
		public boolean isSetValue() {
			return this.value != null;
		}

		public void setValueIsSet(boolean value) {
			if (!value) {
				this.value = null;
			}
		}

		public long getTimestamp() {
			return this.timestamp;
		}

		public insert_args setTimestamp(long timestamp) {
			this.timestamp = timestamp;
			setTimestampIsSet(true);
			return this;
		}

		public void unsetTimestamp() {
			__isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
		}

		// Returns true if field timestamp is set (has been asigned a value) and
		// false otherwise
		public boolean isSetTimestamp() {
			return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
		}

		public void setTimestampIsSet(boolean value) {
			__isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public insert_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEY:
				if (value == null) {
					unsetKey();
				} else {
					setKey((String) value);
				}
				break;

			case COLUMN_PATH:
				if (value == null) {
					unsetColumn_path();
				} else {
					setColumn_path((ColumnPath) value);
				}
				break;

			case VALUE:
				if (value == null) {
					unsetValue();
				} else {
					setValue((byte[]) value);
				}
				break;

			case TIMESTAMP:
				if (value == null) {
					unsetTimestamp();
				} else {
					setTimestamp((Long) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEY:
				return getKey();

			case COLUMN_PATH:
				return getColumn_path();

			case VALUE:
				return getValue();

			case TIMESTAMP:
				return new Long(getTimestamp());

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEY:
				return isSetKey();
			case COLUMN_PATH:
				return isSetColumn_path();
			case VALUE:
				return isSetValue();
			case TIMESTAMP:
				return isSetTimestamp();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof insert_args)
				return this.equals((insert_args) that);
			return false;
		}

		public boolean equals(insert_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_key = true && this.isSetKey();
			boolean that_present_key = true && that.isSetKey();
			if (this_present_key || that_present_key) {
				if (!(this_present_key && that_present_key))
					return false;
				if (!this.key.equals(that.key))
					return false;
			}

			boolean this_present_column_path = true && this.isSetColumn_path();
			boolean that_present_column_path = true && that.isSetColumn_path();
			if (this_present_column_path || that_present_column_path) {
				if (!(this_present_column_path && that_present_column_path))
					return false;
				if (!this.column_path.equals(that.column_path))
					return false;
			}

			boolean this_present_value = true && this.isSetValue();
			boolean that_present_value = true && that.isSetValue();
			if (this_present_value || that_present_value) {
				if (!(this_present_value && that_present_value))
					return false;
				if (!java.util.Arrays.equals(this.value, that.value))
					return false;
			}

			boolean this_present_timestamp = true;
			boolean that_present_timestamp = true;
			if (this_present_timestamp || that_present_timestamp) {
				if (!(this_present_timestamp && that_present_timestamp))
					return false;
				if (this.timestamp != that.timestamp)
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(insert_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			insert_args typedOther = (insert_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(key, typedOther.key);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetValue()).compareTo(isSetValue());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(value, typedOther.value);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(isSetTimestamp());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEY:
					if (field.type == TType.STRING) {
						this.key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PATH:
					if (field.type == TType.STRUCT) {
						this.column_path = new ColumnPath();
						this.column_path.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case VALUE:
					if (field.type == TType.STRING) {
						this.value = iprot.readBinary();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TIMESTAMP:
					if (field.type == TType.I64) {
						this.timestamp = iprot.readI64();
						setTimestampIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetTimestamp()) {
				throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
			}
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.key != null) {
				oprot.writeFieldBegin(KEY_FIELD_DESC);
				oprot.writeString(this.key);
				oprot.writeFieldEnd();
			}
			if (this.column_path != null) {
				oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
				this.column_path.write(oprot);
				oprot.writeFieldEnd();
			}
			if (this.value != null) {
				oprot.writeFieldBegin(VALUE_FIELD_DESC);
				oprot.writeBinary(this.value);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
			oprot.writeI64(this.timestamp);
			oprot.writeFieldEnd();
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("insert_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("key:");
			if (this.key == null) {
				sb.append("null");
			} else {
				sb.append(this.key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_path:");
			if (this.column_path == null) {
				sb.append("null");
			} else {
				sb.append(this.column_path);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("value:");
			if (this.value == null) {
				sb.append("null");
			} else {
				int __value_size = Math.min(this.value.length, 128);
				for (int i = 0; i < __value_size; i++) {
					if (i != 0)
						sb.append(" ");
					sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0"
							+ Integer.toHexString(this.value[i]).toUpperCase());
				}
				if (this.value.length > 128)
					sb.append(" ...");
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("timestamp:");
			sb.append(this.timestamp);
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (key == null) {
				throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
			}
			if (column_path == null) {
				throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
			}
			if (value == null) {
				throw new TProtocolException("Required field 'value' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'timestamp' because it's a primitive and
			// you chose the non-beans generator.
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class insert_result implements TBase, java.io.Serializable, Cloneable, Comparable<insert_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("insert_result");
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(insert_result.class, metaDataMap);
		}

		public insert_result() {
		}

		public insert_result(InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public insert_result(insert_result other) {
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public insert_result deepCopy() {
			return new insert_result(this);
		}

		@Deprecated
		public insert_result clone() {
			return new insert_result(this);
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public insert_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public insert_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public insert_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof insert_result)
				return this.equals((insert_result) that);
			return false;
		}

		public boolean equals(insert_result that) {
			if (that == null)
				return false;

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(insert_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			insert_result typedOther = (insert_result) other;

			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("insert_result(");
			boolean first = true;

			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class batch_insert_args implements TBase, java.io.Serializable, Cloneable {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("batch_insert_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short) 2);
		private static final TField CFMAP_FIELD_DESC = new TField("cfmap", TType.MAP, (short) 3);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 4);

		public String keyspace;
		public String key;
		public Map<String, List<ColumnOrSuperColumn>> cfmap;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEY = 2;
		public static final int CFMAP = 3;
		public static final int CONSISTENCY_LEVEL = 4;

		// isset id assignments
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
		private BitSet __isset_bit_vector = new BitSet(1);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(CFMAP, new FieldMetaData("cfmap", TFieldRequirementType.REQUIRED, new MapMetaData(TType.MAP, new FieldValueMetaData(TType.STRING), new ListMetaData(TType.LIST, new StructMetaData(
						TType.STRUCT, ColumnOrSuperColumn.class)))));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(batch_insert_args.class, metaDataMap);
		}

		public batch_insert_args() {
			this.consistency_level = 0;

		}

		public batch_insert_args(String keyspace, String key, Map<String, List<ColumnOrSuperColumn>> cfmap, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.key = key;
			this.cfmap = cfmap;
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public batch_insert_args(batch_insert_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKey()) {
				this.key = other.key;
			}
			if (other.isSetCfmap()) {
				Map<String, List<ColumnOrSuperColumn>> __this__cfmap = new HashMap<String, List<ColumnOrSuperColumn>>();
				for (Map.Entry<String, List<ColumnOrSuperColumn>> other_element : other.cfmap.entrySet()) {

					String other_element_key = other_element.getKey();
					List<ColumnOrSuperColumn> other_element_value = other_element.getValue();

					String __this__cfmap_copy_key = other_element_key;

					List<ColumnOrSuperColumn> __this__cfmap_copy_value = new ArrayList<ColumnOrSuperColumn>();
					for (ColumnOrSuperColumn other_element_value_element : other_element_value) {
						__this__cfmap_copy_value.add(new ColumnOrSuperColumn(other_element_value_element));
					}

					__this__cfmap.put(__this__cfmap_copy_key, __this__cfmap_copy_value);
				}
				this.cfmap = __this__cfmap;
			}
			this.consistency_level = other.consistency_level;
		}

		public batch_insert_args deepCopy() {
			return new batch_insert_args(this);
		}

		@Deprecated
		public batch_insert_args clone() {
			return new batch_insert_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public batch_insert_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public String getKey() {
			return this.key;
		}

		public batch_insert_args setKey(String key) {
			this.key = key;
			return this;
		}

		public void unsetKey() {
			this.key = null;
		}

		// Returns true if field key is set (has been asigned a value) and false
		// otherwise
		public boolean isSetKey() {
			return this.key != null;
		}

		public void setKeyIsSet(boolean value) {
			if (!value) {
				this.key = null;
			}
		}

		public int getCfmapSize() {
			return (this.cfmap == null) ? 0 : this.cfmap.size();
		}

		public void putToCfmap(String key, List<ColumnOrSuperColumn> val) {
			if (this.cfmap == null) {
				this.cfmap = new HashMap<String, List<ColumnOrSuperColumn>>();
			}
			this.cfmap.put(key, val);
		}

		public Map<String, List<ColumnOrSuperColumn>> getCfmap() {
			return this.cfmap;
		}

		public batch_insert_args setCfmap(Map<String, List<ColumnOrSuperColumn>> cfmap) {
			this.cfmap = cfmap;
			return this;
		}

		public void unsetCfmap() {
			this.cfmap = null;
		}

		// Returns true if field cfmap is set (has been asigned a value) and
		// false otherwise
		public boolean isSetCfmap() {
			return this.cfmap != null;
		}

		public void setCfmapIsSet(boolean value) {
			if (!value) {
				this.cfmap = null;
			}
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public batch_insert_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEY:
				if (value == null) {
					unsetKey();
				} else {
					setKey((String) value);
				}
				break;

			case CFMAP:
				if (value == null) {
					unsetCfmap();
				} else {
					setCfmap((Map<String, List<ColumnOrSuperColumn>>) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEY:
				return getKey();

			case CFMAP:
				return getCfmap();

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEY:
				return isSetKey();
			case CFMAP:
				return isSetCfmap();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof batch_insert_args)
				return this.equals((batch_insert_args) that);
			return false;
		}

		public boolean equals(batch_insert_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_key = true && this.isSetKey();
			boolean that_present_key = true && that.isSetKey();
			if (this_present_key || that_present_key) {
				if (!(this_present_key && that_present_key))
					return false;
				if (!this.key.equals(that.key))
					return false;
			}

			boolean this_present_cfmap = true && this.isSetCfmap();
			boolean that_present_cfmap = true && that.isSetCfmap();
			if (this_present_cfmap || that_present_cfmap) {
				if (!(this_present_cfmap && that_present_cfmap))
					return false;
				if (!this.cfmap.equals(that.cfmap))
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEY:
					if (field.type == TType.STRING) {
						this.key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CFMAP:
					if (field.type == TType.MAP) {
						{
							TMap _map46 = iprot.readMapBegin();
							this.cfmap = new HashMap<String, List<ColumnOrSuperColumn>>(2 * _map46.size);
							for (int _i47 = 0; _i47 < _map46.size; ++_i47) {
								String _key48;
								List<ColumnOrSuperColumn> _val49;
								_key48 = iprot.readString();
								{
									TList _list50 = iprot.readListBegin();
									_val49 = new ArrayList<ColumnOrSuperColumn>(_list50.size);
									for (int _i51 = 0; _i51 < _list50.size; ++_i51) {
										ColumnOrSuperColumn _elem52;
										_elem52 = new ColumnOrSuperColumn();
										_elem52.read(iprot);
										_val49.add(_elem52);
									}
									iprot.readListEnd();
								}
								this.cfmap.put(_key48, _val49);
							}
							iprot.readMapEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetConsistency_level()) {
				throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.key != null) {
				oprot.writeFieldBegin(KEY_FIELD_DESC);
				oprot.writeString(this.key);
				oprot.writeFieldEnd();
			}
			if (this.cfmap != null) {
				oprot.writeFieldBegin(CFMAP_FIELD_DESC);
				{
					oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.cfmap.size()));
					for (Map.Entry<String, List<ColumnOrSuperColumn>> _iter53 : this.cfmap.entrySet()) {
						oprot.writeString(_iter53.getKey());
						{
							oprot.writeListBegin(new TList(TType.STRUCT, _iter53.getValue().size()));
							for (ColumnOrSuperColumn _iter54 : _iter53.getValue()) {
								_iter54.write(oprot);
							}
							oprot.writeListEnd();
						}
					}
					oprot.writeMapEnd();
				}
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("batch_insert_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("key:");
			if (this.key == null) {
				sb.append("null");
			} else {
				sb.append(this.key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("cfmap:");
			if (this.cfmap == null) {
				sb.append("null");
			} else {
				sb.append(this.cfmap);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (key == null) {
				throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
			}
			if (cfmap == null) {
				throw new TProtocolException("Required field 'cfmap' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'consistency_level' because it's a
			// primitive and you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class batch_insert_result implements TBase, java.io.Serializable, Cloneable, Comparable<batch_insert_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("batch_insert_result");
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(batch_insert_result.class, metaDataMap);
		}

		public batch_insert_result() {
		}

		public batch_insert_result(InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public batch_insert_result(batch_insert_result other) {
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public batch_insert_result deepCopy() {
			return new batch_insert_result(this);
		}

		@Deprecated
		public batch_insert_result clone() {
			return new batch_insert_result(this);
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public batch_insert_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public batch_insert_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public batch_insert_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof batch_insert_result)
				return this.equals((batch_insert_result) that);
			return false;
		}

		public boolean equals(batch_insert_result that) {
			if (that == null)
				return false;

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(batch_insert_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			batch_insert_result typedOther = (batch_insert_result) other;

			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("batch_insert_result(");
			boolean first = true;

			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class remove_args implements TBase, java.io.Serializable, Cloneable, Comparable<remove_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("remove_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);
		private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short) 2);
		private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short) 3);
		private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short) 4);
		private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short) 5);

		public String keyspace;
		public String key;
		public ColumnPath column_path;
		public long timestamp;
		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int consistency_level;
		public static final int KEYSPACE = 1;
		public static final int KEY = 2;
		public static final int COLUMN_PATH = 3;
		public static final int TIMESTAMP = 4;
		public static final int CONSISTENCY_LEVEL = 5;

		// isset id assignments
		private static final int __TIMESTAMP_ISSET_ID = 0;
		private static final int __CONSISTENCY_LEVEL_ISSET_ID = 1;
		private BitSet __isset_bit_vector = new BitSet(2);

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
				put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, new StructMetaData(TType.STRUCT, ColumnPath.class)));
				put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.I64)));
				put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.I32)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
		}

		public remove_args() {
			this.consistency_level = 0;

		}

		public remove_args(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) {
			this();
			this.keyspace = keyspace;
			this.key = key;
			this.column_path = column_path;
			this.timestamp = timestamp;
			setTimestampIsSet(true);
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public remove_args(remove_args other) {
			__isset_bit_vector.clear();
			__isset_bit_vector.or(other.__isset_bit_vector);
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
			if (other.isSetKey()) {
				this.key = other.key;
			}
			if (other.isSetColumn_path()) {
				this.column_path = new ColumnPath(other.column_path);
			}
			this.timestamp = other.timestamp;
			this.consistency_level = other.consistency_level;
		}

		public remove_args deepCopy() {
			return new remove_args(this);
		}

		@Deprecated
		public remove_args clone() {
			return new remove_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public remove_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public String getKey() {
			return this.key;
		}

		public remove_args setKey(String key) {
			this.key = key;
			return this;
		}

		public void unsetKey() {
			this.key = null;
		}

		// Returns true if field key is set (has been asigned a value) and false
		// otherwise
		public boolean isSetKey() {
			return this.key != null;
		}

		public void setKeyIsSet(boolean value) {
			if (!value) {
				this.key = null;
			}
		}

		public ColumnPath getColumn_path() {
			return this.column_path;
		}

		public remove_args setColumn_path(ColumnPath column_path) {
			this.column_path = column_path;
			return this;
		}

		public void unsetColumn_path() {
			this.column_path = null;
		}

		// Returns true if field column_path is set (has been asigned a value)
		// and false otherwise
		public boolean isSetColumn_path() {
			return this.column_path != null;
		}

		public void setColumn_pathIsSet(boolean value) {
			if (!value) {
				this.column_path = null;
			}
		}

		public long getTimestamp() {
			return this.timestamp;
		}

		public remove_args setTimestamp(long timestamp) {
			this.timestamp = timestamp;
			setTimestampIsSet(true);
			return this;
		}

		public void unsetTimestamp() {
			__isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
		}

		// Returns true if field timestamp is set (has been asigned a value) and
		// false otherwise
		public boolean isSetTimestamp() {
			return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
		}

		public void setTimestampIsSet(boolean value) {
			__isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public int getConsistency_level() {
			return this.consistency_level;
		}

		/**
		 * 
		 * @see ConsistencyLevel
		 */
		public remove_args setConsistency_level(int consistency_level) {
			this.consistency_level = consistency_level;
			setConsistency_levelIsSet(true);
			return this;
		}

		public void unsetConsistency_level() {
			__isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		// Returns true if field consistency_level is set (has been asigned a
		// value) and false otherwise
		public boolean isSetConsistency_level() {
			return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
		}

		public void setConsistency_levelIsSet(boolean value) {
			__isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			case KEY:
				if (value == null) {
					unsetKey();
				} else {
					setKey((String) value);
				}
				break;

			case COLUMN_PATH:
				if (value == null) {
					unsetColumn_path();
				} else {
					setColumn_path((ColumnPath) value);
				}
				break;

			case TIMESTAMP:
				if (value == null) {
					unsetTimestamp();
				} else {
					setTimestamp((Long) value);
				}
				break;

			case CONSISTENCY_LEVEL:
				if (value == null) {
					unsetConsistency_level();
				} else {
					setConsistency_level((Integer) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			case KEY:
				return getKey();

			case COLUMN_PATH:
				return getColumn_path();

			case TIMESTAMP:
				return new Long(getTimestamp());

			case CONSISTENCY_LEVEL:
				return getConsistency_level();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			case KEY:
				return isSetKey();
			case COLUMN_PATH:
				return isSetColumn_path();
			case TIMESTAMP:
				return isSetTimestamp();
			case CONSISTENCY_LEVEL:
				return isSetConsistency_level();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof remove_args)
				return this.equals((remove_args) that);
			return false;
		}

		public boolean equals(remove_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			boolean this_present_key = true && this.isSetKey();
			boolean that_present_key = true && that.isSetKey();
			if (this_present_key || that_present_key) {
				if (!(this_present_key && that_present_key))
					return false;
				if (!this.key.equals(that.key))
					return false;
			}

			boolean this_present_column_path = true && this.isSetColumn_path();
			boolean that_present_column_path = true && that.isSetColumn_path();
			if (this_present_column_path || that_present_column_path) {
				if (!(this_present_column_path && that_present_column_path))
					return false;
				if (!this.column_path.equals(that.column_path))
					return false;
			}

			boolean this_present_timestamp = true;
			boolean that_present_timestamp = true;
			if (this_present_timestamp || that_present_timestamp) {
				if (!(this_present_timestamp && that_present_timestamp))
					return false;
				if (this.timestamp != that.timestamp)
					return false;
			}

			boolean this_present_consistency_level = true;
			boolean that_present_consistency_level = true;
			if (this_present_consistency_level || that_present_consistency_level) {
				if (!(this_present_consistency_level && that_present_consistency_level))
					return false;
				if (this.consistency_level != that.consistency_level)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(remove_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			remove_args typedOther = (remove_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(key, typedOther.key);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(isSetTimestamp());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case KEY:
					if (field.type == TType.STRING) {
						this.key = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case COLUMN_PATH:
					if (field.type == TType.STRUCT) {
						this.column_path = new ColumnPath();
						this.column_path.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TIMESTAMP:
					if (field.type == TType.I64) {
						this.timestamp = iprot.readI64();
						setTimestampIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case CONSISTENCY_LEVEL:
					if (field.type == TType.I32) {
						this.consistency_level = iprot.readI32();
						setConsistency_levelIsSet(true);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			if (!isSetTimestamp()) {
				throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
			}
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			if (this.key != null) {
				oprot.writeFieldBegin(KEY_FIELD_DESC);
				oprot.writeString(this.key);
				oprot.writeFieldEnd();
			}
			if (this.column_path != null) {
				oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
				this.column_path.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
			oprot.writeI64(this.timestamp);
			oprot.writeFieldEnd();
			oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
			oprot.writeI32(this.consistency_level);
			oprot.writeFieldEnd();
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("remove_args(");
			boolean first = true;

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("key:");
			if (this.key == null) {
				sb.append("null");
			} else {
				sb.append(this.key);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("column_path:");
			if (this.column_path == null) {
				sb.append("null");
			} else {
				sb.append(this.column_path);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("timestamp:");
			sb.append(this.timestamp);
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("consistency_level:");
			String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(consistency_level_name);
				sb.append(" (");
			}
			sb.append(this.consistency_level);
			if (consistency_level_name != null) {
				sb.append(")");
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			if (key == null) {
				throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
			}
			if (column_path == null) {
				throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
			}
			// alas, we cannot check 'timestamp' because it's a primitive and
			// you chose the non-beans generator.
			// check that fields of type enum have valid values
			if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)) {
				throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
			}
		}

	}

	public static class remove_result implements TBase, java.io.Serializable, Cloneable, Comparable<remove_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("remove_result");
		private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short) 1);
		private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short) 2);
		private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short) 3);

		public InvalidRequestException ire;
		public UnavailableException ue;
		public TimedOutException te;
		public static final int IRE = 1;
		public static final int UE = 2;
		public static final int TE = 3;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
				put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
		}

		public remove_result() {
		}

		public remove_result(InvalidRequestException ire, UnavailableException ue, TimedOutException te) {
			this();
			this.ire = ire;
			this.ue = ue;
			this.te = te;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public remove_result(remove_result other) {
			if (other.isSetIre()) {
				this.ire = new InvalidRequestException(other.ire);
			}
			if (other.isSetUe()) {
				this.ue = new UnavailableException(other.ue);
			}
			if (other.isSetTe()) {
				this.te = new TimedOutException(other.te);
			}
		}

		public remove_result deepCopy() {
			return new remove_result(this);
		}

		@Deprecated
		public remove_result clone() {
			return new remove_result(this);
		}

		public InvalidRequestException getIre() {
			return this.ire;
		}

		public remove_result setIre(InvalidRequestException ire) {
			this.ire = ire;
			return this;
		}

		public void unsetIre() {
			this.ire = null;
		}

		// Returns true if field ire is set (has been asigned a value) and false
		// otherwise
		public boolean isSetIre() {
			return this.ire != null;
		}

		public void setIreIsSet(boolean value) {
			if (!value) {
				this.ire = null;
			}
		}

		public UnavailableException getUe() {
			return this.ue;
		}

		public remove_result setUe(UnavailableException ue) {
			this.ue = ue;
			return this;
		}

		public void unsetUe() {
			this.ue = null;
		}

		// Returns true if field ue is set (has been asigned a value) and false
		// otherwise
		public boolean isSetUe() {
			return this.ue != null;
		}

		public void setUeIsSet(boolean value) {
			if (!value) {
				this.ue = null;
			}
		}

		public TimedOutException getTe() {
			return this.te;
		}

		public remove_result setTe(TimedOutException te) {
			this.te = te;
			return this;
		}

		public void unsetTe() {
			this.te = null;
		}

		// Returns true if field te is set (has been asigned a value) and false
		// otherwise
		public boolean isSetTe() {
			return this.te != null;
		}

		public void setTeIsSet(boolean value) {
			if (!value) {
				this.te = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case IRE:
				if (value == null) {
					unsetIre();
				} else {
					setIre((InvalidRequestException) value);
				}
				break;

			case UE:
				if (value == null) {
					unsetUe();
				} else {
					setUe((UnavailableException) value);
				}
				break;

			case TE:
				if (value == null) {
					unsetTe();
				} else {
					setTe((TimedOutException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case IRE:
				return getIre();

			case UE:
				return getUe();

			case TE:
				return getTe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case IRE:
				return isSetIre();
			case UE:
				return isSetUe();
			case TE:
				return isSetTe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof remove_result)
				return this.equals((remove_result) that);
			return false;
		}

		public boolean equals(remove_result that) {
			if (that == null)
				return false;

			boolean this_present_ire = true && this.isSetIre();
			boolean that_present_ire = true && that.isSetIre();
			if (this_present_ire || that_present_ire) {
				if (!(this_present_ire && that_present_ire))
					return false;
				if (!this.ire.equals(that.ire))
					return false;
			}

			boolean this_present_ue = true && this.isSetUe();
			boolean that_present_ue = true && that.isSetUe();
			if (this_present_ue || that_present_ue) {
				if (!(this_present_ue && that_present_ue))
					return false;
				if (!this.ue.equals(that.ue))
					return false;
			}

			boolean this_present_te = true && this.isSetTe();
			boolean that_present_te = true && that.isSetTe();
			if (this_present_te || that_present_te) {
				if (!(this_present_te && that_present_te))
					return false;
				if (!this.te.equals(that.te))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(remove_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			remove_result typedOther = (remove_result) other;

			lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(te, typedOther.te);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case IRE:
					if (field.type == TType.STRUCT) {
						this.ire = new InvalidRequestException();
						this.ire.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case UE:
					if (field.type == TType.STRUCT) {
						this.ue = new UnavailableException();
						this.ue.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case TE:
					if (field.type == TType.STRUCT) {
						this.te = new TimedOutException();
						this.te.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetIre()) {
				oprot.writeFieldBegin(IRE_FIELD_DESC);
				this.ire.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetUe()) {
				oprot.writeFieldBegin(UE_FIELD_DESC);
				this.ue.write(oprot);
				oprot.writeFieldEnd();
			} else if (this.isSetTe()) {
				oprot.writeFieldBegin(TE_FIELD_DESC);
				this.te.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("remove_result(");
			boolean first = true;

			sb.append("ire:");
			if (this.ire == null) {
				sb.append("null");
			} else {
				sb.append(this.ire);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("ue:");
			if (this.ue == null) {
				sb.append("null");
			} else {
				sb.append(this.ue);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("te:");
			if (this.te == null) {
				sb.append("null");
			} else {
				sb.append(this.te);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class get_string_property_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_property_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_string_property_args");
		private static final TField PROPERTY_FIELD_DESC = new TField("property", TType.STRING, (short) 1);

		public String property;
		public static final int PROPERTY = 1;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(PROPERTY, new FieldMetaData("property", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_string_property_args.class, metaDataMap);
		}

		public get_string_property_args() {
		}

		public get_string_property_args(String property) {
			this();
			this.property = property;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_string_property_args(get_string_property_args other) {
			if (other.isSetProperty()) {
				this.property = other.property;
			}
		}

		public get_string_property_args deepCopy() {
			return new get_string_property_args(this);
		}

		@Deprecated
		public get_string_property_args clone() {
			return new get_string_property_args(this);
		}

		public String getProperty() {
			return this.property;
		}

		public get_string_property_args setProperty(String property) {
			this.property = property;
			return this;
		}

		public void unsetProperty() {
			this.property = null;
		}

		// Returns true if field property is set (has been asigned a value) and
		// false otherwise
		public boolean isSetProperty() {
			return this.property != null;
		}

		public void setPropertyIsSet(boolean value) {
			if (!value) {
				this.property = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case PROPERTY:
				if (value == null) {
					unsetProperty();
				} else {
					setProperty((String) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case PROPERTY:
				return getProperty();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case PROPERTY:
				return isSetProperty();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_string_property_args)
				return this.equals((get_string_property_args) that);
			return false;
		}

		public boolean equals(get_string_property_args that) {
			if (that == null)
				return false;

			boolean this_present_property = true && this.isSetProperty();
			boolean that_present_property = true && that.isSetProperty();
			if (this_present_property || that_present_property) {
				if (!(this_present_property && that_present_property))
					return false;
				if (!this.property.equals(that.property))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_string_property_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_string_property_args typedOther = (get_string_property_args) other;

			lastComparison = Boolean.valueOf(isSetProperty()).compareTo(isSetProperty());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(property, typedOther.property);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case PROPERTY:
					if (field.type == TType.STRING) {
						this.property = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.property != null) {
				oprot.writeFieldBegin(PROPERTY_FIELD_DESC);
				oprot.writeString(this.property);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_string_property_args(");

			sb.append("property:");
			if (this.property == null) {
				sb.append("null");
			} else {
				sb.append(this.property);
			}
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (property == null) {
				throw new TProtocolException("Required field 'property' was not present! Struct: " + toString());
			}
			// check that fields of type enum have valid values
		}

	}

	public static class get_string_property_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_property_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_string_property_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short) 0);

		public String success;
		public static final int SUCCESS = 0;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRING)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_string_property_result.class, metaDataMap);
		}

		public get_string_property_result() {
		}

		public get_string_property_result(String success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_string_property_result(get_string_property_result other) {
			if (other.isSetSuccess()) {
				this.success = other.success;
			}
		}

		public get_string_property_result deepCopy() {
			return new get_string_property_result(this);
		}

		@Deprecated
		public get_string_property_result clone() {
			return new get_string_property_result(this);
		}

		public String getSuccess() {
			return this.success;
		}

		public get_string_property_result setSuccess(String success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((String) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_string_property_result)
				return this.equals((get_string_property_result) that);
			return false;
		}

		public boolean equals(get_string_property_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_string_property_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_string_property_result typedOther = (get_string_property_result) other;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(success, typedOther.success);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.STRING) {
						this.success = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				oprot.writeString(this.success);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_string_property_result(");

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class get_string_list_property_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_list_property_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_string_list_property_args");
		private static final TField PROPERTY_FIELD_DESC = new TField("property", TType.STRING, (short) 1);

		public String property;
		public static final int PROPERTY = 1;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(PROPERTY, new FieldMetaData("property", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_string_list_property_args.class, metaDataMap);
		}

		public get_string_list_property_args() {
		}

		public get_string_list_property_args(String property) {
			this();
			this.property = property;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_string_list_property_args(get_string_list_property_args other) {
			if (other.isSetProperty()) {
				this.property = other.property;
			}
		}

		public get_string_list_property_args deepCopy() {
			return new get_string_list_property_args(this);
		}

		@Deprecated
		public get_string_list_property_args clone() {
			return new get_string_list_property_args(this);
		}

		public String getProperty() {
			return this.property;
		}

		public get_string_list_property_args setProperty(String property) {
			this.property = property;
			return this;
		}

		public void unsetProperty() {
			this.property = null;
		}

		// Returns true if field property is set (has been asigned a value) and
		// false otherwise
		public boolean isSetProperty() {
			return this.property != null;
		}

		public void setPropertyIsSet(boolean value) {
			if (!value) {
				this.property = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case PROPERTY:
				if (value == null) {
					unsetProperty();
				} else {
					setProperty((String) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case PROPERTY:
				return getProperty();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case PROPERTY:
				return isSetProperty();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_string_list_property_args)
				return this.equals((get_string_list_property_args) that);
			return false;
		}

		public boolean equals(get_string_list_property_args that) {
			if (that == null)
				return false;

			boolean this_present_property = true && this.isSetProperty();
			boolean that_present_property = true && that.isSetProperty();
			if (this_present_property || that_present_property) {
				if (!(this_present_property && that_present_property))
					return false;
				if (!this.property.equals(that.property))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_string_list_property_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_string_list_property_args typedOther = (get_string_list_property_args) other;

			lastComparison = Boolean.valueOf(isSetProperty()).compareTo(isSetProperty());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(property, typedOther.property);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case PROPERTY:
					if (field.type == TType.STRING) {
						this.property = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.property != null) {
				oprot.writeFieldBegin(PROPERTY_FIELD_DESC);
				oprot.writeString(this.property);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_string_list_property_args(");

			sb.append("property:");
			if (this.property == null) {
				sb.append("null");
			} else {
				sb.append(this.property);
			}
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (property == null) {
				throw new TProtocolException("Required field 'property' was not present! Struct: " + toString());
			}
			// check that fields of type enum have valid values
		}

	}

	public static class get_string_list_property_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_list_property_result> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("get_string_list_property_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short) 0);

		public List<String> success;
		public static final int SUCCESS = 0;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new ListMetaData(TType.LIST, new FieldValueMetaData(TType.STRING))));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(get_string_list_property_result.class, metaDataMap);
		}

		public get_string_list_property_result() {
		}

		public get_string_list_property_result(List<String> success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public get_string_list_property_result(get_string_list_property_result other) {
			if (other.isSetSuccess()) {
				List<String> __this__success = new ArrayList<String>();
				for (String other_element : other.success) {
					__this__success.add(other_element);
				}
				this.success = __this__success;
			}
		}

		public get_string_list_property_result deepCopy() {
			return new get_string_list_property_result(this);
		}

		@Deprecated
		public get_string_list_property_result clone() {
			return new get_string_list_property_result(this);
		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public java.util.Iterator<String> getSuccessIterator() {
			return (this.success == null) ? null : this.success.iterator();
		}

		public void addToSuccess(String elem) {
			if (this.success == null) {
				this.success = new ArrayList<String>();
			}
			this.success.add(elem);
		}

		public List<String> getSuccess() {
			return this.success;
		}

		public get_string_list_property_result setSuccess(List<String> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((List<String>) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof get_string_list_property_result)
				return this.equals((get_string_list_property_result) that);
			return false;
		}

		public boolean equals(get_string_list_property_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(get_string_list_property_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			get_string_list_property_result typedOther = (get_string_list_property_result) other;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(success, typedOther.success);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.LIST) {
						{
							TList _list55 = iprot.readListBegin();
							this.success = new ArrayList<String>(_list55.size);
							for (int _i56 = 0; _i56 < _list55.size; ++_i56) {
								String _elem57;
								_elem57 = iprot.readString();
								this.success.add(_elem57);
							}
							iprot.readListEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				{
					oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
					for (String _iter58 : this.success) {
						oprot.writeString(_iter58);
					}
					oprot.writeListEnd();
				}
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("get_string_list_property_result(");

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

	public static class describe_keyspace_args implements TBase, java.io.Serializable, Cloneable, Comparable<describe_keyspace_args> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_args");
		private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short) 1);

		public String keyspace;
		public static final int KEYSPACE = 1;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, new FieldValueMetaData(TType.STRING)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(describe_keyspace_args.class, metaDataMap);
		}

		public describe_keyspace_args() {
		}

		public describe_keyspace_args(String keyspace) {
			this();
			this.keyspace = keyspace;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public describe_keyspace_args(describe_keyspace_args other) {
			if (other.isSetKeyspace()) {
				this.keyspace = other.keyspace;
			}
		}

		public describe_keyspace_args deepCopy() {
			return new describe_keyspace_args(this);
		}

		@Deprecated
		public describe_keyspace_args clone() {
			return new describe_keyspace_args(this);
		}

		public String getKeyspace() {
			return this.keyspace;
		}

		public describe_keyspace_args setKeyspace(String keyspace) {
			this.keyspace = keyspace;
			return this;
		}

		public void unsetKeyspace() {
			this.keyspace = null;
		}

		// Returns true if field keyspace is set (has been asigned a value) and
		// false otherwise
		public boolean isSetKeyspace() {
			return this.keyspace != null;
		}

		public void setKeyspaceIsSet(boolean value) {
			if (!value) {
				this.keyspace = null;
			}
		}

		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case KEYSPACE:
				if (value == null) {
					unsetKeyspace();
				} else {
					setKeyspace((String) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return getKeyspace();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case KEYSPACE:
				return isSetKeyspace();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof describe_keyspace_args)
				return this.equals((describe_keyspace_args) that);
			return false;
		}

		public boolean equals(describe_keyspace_args that) {
			if (that == null)
				return false;

			boolean this_present_keyspace = true && this.isSetKeyspace();
			boolean that_present_keyspace = true && that.isSetKeyspace();
			if (this_present_keyspace || that_present_keyspace) {
				if (!(this_present_keyspace && that_present_keyspace))
					return false;
				if (!this.keyspace.equals(that.keyspace))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public int compareTo(describe_keyspace_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;
			describe_keyspace_args typedOther = (describe_keyspace_args) other;

			lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
			if (lastComparison != 0) {
				return lastComparison;
			}
			lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
			if (lastComparison != 0) {
				return lastComparison;
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case KEYSPACE:
					if (field.type == TType.STRING) {
						this.keyspace = iprot.readString();
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (this.keyspace != null) {
				oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
				oprot.writeString(this.keyspace);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("describe_keyspace_args(");

			sb.append("keyspace:");
			if (this.keyspace == null) {
				sb.append("null");
			} else {
				sb.append(this.keyspace);
			}
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			if (keyspace == null) {
				throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
			}
			// check that fields of type enum have valid values
		}

	}

	public static class describe_keyspace_result implements TBase, java.io.Serializable, Cloneable {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_result");
		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short) 0);
		private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short) 1);

		public Map<String, Map<String, String>> success;
		public NotFoundException nfe;
		public static final int SUCCESS = 0;
		public static final int NFE = 1;

		// isset id assignments

		public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			{
				put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, new MapMetaData(TType.MAP, new FieldValueMetaData(TType.STRING), new MapMetaData(TType.MAP,
						new FieldValueMetaData(TType.STRING), new FieldValueMetaData(TType.STRING)))));
				put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, new FieldValueMetaData(TType.STRUCT)));
			}
		});

		static {
			FieldMetaData.addStructMetaDataMap(describe_keyspace_result.class, metaDataMap);
		}

		public describe_keyspace_result() {
		}

		public describe_keyspace_result(Map<String, Map<String, String>> success, NotFoundException nfe) {
			this();
			this.success = success;
			this.nfe = nfe;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public describe_keyspace_result(describe_keyspace_result other) {
			if (other.isSetSuccess()) {
				Map<String, Map<String, String>> __this__success = new HashMap<String, Map<String, String>>();
				for (Map.Entry<String, Map<String, String>> other_element : other.success.entrySet()) {

					String other_element_key = other_element.getKey();
					Map<String, String> other_element_value = other_element.getValue();

					String __this__success_copy_key = other_element_key;

					Map<String, String> __this__success_copy_value = new HashMap<String, String>();
					for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {

						String other_element_value_element_key = other_element_value_element.getKey();
						String other_element_value_element_value = other_element_value_element.getValue();

						String __this__success_copy_value_copy_key = other_element_value_element_key;

						String __this__success_copy_value_copy_value = other_element_value_element_value;

						__this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
					}

					__this__success.put(__this__success_copy_key, __this__success_copy_value);
				}
				this.success = __this__success;
			}
			if (other.isSetNfe()) {
				this.nfe = new NotFoundException(other.nfe);
			}
		}

		public describe_keyspace_result deepCopy() {
			return new describe_keyspace_result(this);
		}

		@Deprecated
		public describe_keyspace_result clone() {
			return new describe_keyspace_result(this);
		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public void putToSuccess(String key, Map<String, String> val) {
			if (this.success == null) {
				this.success = new HashMap<String, Map<String, String>>();
			}
			this.success.put(key, val);
		}

		public Map<String, Map<String, String>> getSuccess() {
			return this.success;
		}

		public describe_keyspace_result setSuccess(Map<String, Map<String, String>> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		// Returns true if field success is set (has been asigned a value) and
		// false otherwise
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public NotFoundException getNfe() {
			return this.nfe;
		}

		public describe_keyspace_result setNfe(NotFoundException nfe) {
			this.nfe = nfe;
			return this;
		}

		public void unsetNfe() {
			this.nfe = null;
		}

		// Returns true if field nfe is set (has been asigned a value) and false
		// otherwise
		public boolean isSetNfe() {
			return this.nfe != null;
		}

		public void setNfeIsSet(boolean value) {
			if (!value) {
				this.nfe = null;
			}
		}

		@SuppressWarnings("unchecked")
		public void setFieldValue(int fieldID, Object value) {
			switch (fieldID) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Map<String, Map<String, String>>) value);
				}
				break;

			case NFE:
				if (value == null) {
					unsetNfe();
				} else {
					setNfe((NotFoundException) value);
				}
				break;

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		public Object getFieldValue(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return getSuccess();

			case NFE:
				return getNfe();

			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		// Returns true if field corresponding to fieldID is set (has been
		// asigned a value) and false otherwise
		public boolean isSet(int fieldID) {
			switch (fieldID) {
			case SUCCESS:
				return isSetSuccess();
			case NFE:
				return isSetNfe();
			default:
				throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
			}
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof describe_keyspace_result)
				return this.equals((describe_keyspace_result) that);
			return false;
		}

		public boolean equals(describe_keyspace_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			boolean this_present_nfe = true && this.isSetNfe();
			boolean that_present_nfe = true && that.isSetNfe();
			if (this_present_nfe || that_present_nfe) {
				if (!(this_present_nfe && that_present_nfe))
					return false;
				if (!this.nfe.equals(that.nfe))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case SUCCESS:
					if (field.type == TType.MAP) {
						{
							TMap _map59 = iprot.readMapBegin();
							this.success = new HashMap<String, Map<String, String>>(2 * _map59.size);
							for (int _i60 = 0; _i60 < _map59.size; ++_i60) {
								String _key61;
								Map<String, String> _val62;
								_key61 = iprot.readString();
								{
									TMap _map63 = iprot.readMapBegin();
									_val62 = new HashMap<String, String>(2 * _map63.size);
									for (int _i64 = 0; _i64 < _map63.size; ++_i64) {
										String _key65;
										String _val66;
										_key65 = iprot.readString();
										_val66 = iprot.readString();
										_val62.put(_key65, _val66);
									}
									iprot.readMapEnd();
								}
								this.success.put(_key61, _val62);
							}
							iprot.readMapEnd();
						}
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				case NFE:
					if (field.type == TType.STRUCT) {
						this.nfe = new NotFoundException();
						this.nfe.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
					break;
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be
			// checked in the validate method
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				{
					oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
					for (Map.Entry<String, Map<String, String>> _iter67 : this.success.entrySet()) {
						oprot.writeString(_iter67.getKey());
						{
							oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter67.getValue().size()));
							for (Map.Entry<String, String> _iter68 : _iter67.getValue().entrySet()) {
								oprot.writeString(_iter68.getKey());
								oprot.writeString(_iter68.getValue());
							}
							oprot.writeMapEnd();
						}
					}
					oprot.writeMapEnd();
				}
				oprot.writeFieldEnd();
			} else if (this.isSetNfe()) {
				oprot.writeFieldBegin(NFE_FIELD_DESC);
				this.nfe.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("describe_keyspace_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			if (!first)
				sb.append(", ");
			sb.append("nfe:");
			if (this.nfe == null) {
				sb.append("null");
			} else {
				sb.append(this.nfe);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
			// check that fields of type enum have valid values
		}

	}

}
